<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Adding Custom Operators for Unstructured Meshes · PoreFlow</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">PoreFlow</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">PoreFlow.jl Documentation</a></li><li><a class="tocitem" href="../gallery/">PDE Galleries</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../coupled/">Coupled Geomechanics and Single Phase Flow</a></li><li><a class="tocitem" href="../staticelasticity/">Static Linear Elasticity</a></li><li><a class="tocitem" href="../plasticity/">Plasticity</a></li><li><a class="tocitem" href="../viscoelasticity/">Viscoelasticity</a></li><li><a class="tocitem" href="../viscoelasticity_earth/">Modeling Viscoelasticity of the Earth</a></li><li><a class="tocitem" href="../earthquake/">Earthquake Simulation with Rate-and-State Friction</a></li><li><a class="tocitem" href="../heatequation/">Heat Equation</a></li><li><a class="tocitem" href="../elastodynamics/">Elastodynamics</a></li><li><a class="tocitem" href="../twophaseflow/">Coupled Geomechanics and Multiphase Flow</a></li><li><a class="tocitem" href="../NavierStokes2/">Navier-Stokes equations</a></li><li><a class="tocitem" href="../SteadyStateNavierStokes/">Steady-state Navier-Stokes equations</a></li><li><a class="tocitem" href="../CHTCoupled/">Conjugate heat transfer coupled solver for incompressible fluid</a></li></ul></li><li><span class="tocitem">Inverse Modeling</span><ul><li><a class="tocitem" href="../inverse/">Inverse Modeling for Poroelasticity Models</a></li><li><a class="tocitem" href="../inv_viscoelasticity/">Inverse Modeling for Space Varying Viscoelasticity</a></li><li><a class="tocitem" href="../coupled_viscoelasticity/">Coupled Viscoelasticity and Single Phase Flow</a></li><li><a class="tocitem" href="../inv_twophaseflow/">Coupled Geomechanics and Multiphase Flow</a></li><li><a class="tocitem" href="../inv_viscoelasticity_nonparametric/">Inverse Modeling for Nonparametric Viscoelasticity</a></li><li><a class="tocitem" href="../inv_viscoelasticity_earth/">Viscoelasticity Model for the Earth</a></li></ul></li><li><span class="tocitem">Unstructured Mesh</span><ul><li><a class="tocitem" href="../mfem_tutorial/">Unstructured Meshes in PoreFlow</a></li><li><a class="tocitem" href="../mfem_mesh/">Construct Unstructured Meshes for PoreFlow</a></li><li class="is-active"><a class="tocitem" href>Adding Custom Operators for Unstructured Meshes</a><ul class="internal"><li><a class="tocitem" href="#Workflow"><span>Workflow</span></a></li><li><a class="tocitem" href="#Assembling-Matrices-and-Vectors"><span>Assembling Matrices and Vectors</span></a></li><li><a class="tocitem" href="#Verifying-Implementation-against-FEniCS"><span>Verifying Implementation against FEniCS</span></a></li><li><a class="tocitem" href="#Install-FEniCS"><span>Install FEniCS</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Unstructured Mesh</a></li><li class="is-active"><a href>Adding Custom Operators for Unstructured Meshes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Adding Custom Operators for Unstructured Meshes</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/kailaix/PoreFlow.jl/blob/master/docs/src/dev_unstructured.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Adding-Custom-Operators-for-Unstructured-Meshes"><a class="docs-heading-anchor" href="#Adding-Custom-Operators-for-Unstructured-Meshes">Adding Custom Operators for Unstructured Meshes</a><a id="Adding-Custom-Operators-for-Unstructured-Meshes-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-Custom-Operators-for-Unstructured-Meshes" title="Permalink"></a></h1><h2 id="Workflow"><a class="docs-heading-anchor" href="#Workflow">Workflow</a><a id="Workflow-1"></a><a class="docs-heading-anchor-permalink" href="#Workflow" title="Permalink"></a></h2><p>This tutorial describes how to develop custom operators for unstructured meshes. </p><p>PoreFlow uses <a href="https://mfem.org/">MFEM</a> as the backend for assembling finite element matrices. However, users, as well as custom operator developers, do not need to know how to use MFEM. PoreFlow has provided an easier interface to essential data structures for assembling finite element matrices. The data structure can be assessed in C++ (see <a href="../api/#PoreFlow.Mesh"><code>Mesh</code></a>) and the header files are located in <code>deps/MFEM/Common.h</code>. As the structured mesh utilties, we do not expose the APIs for Julia users, and therefore if some operators are lacking, users must modify the source codes of PoreFlow. </p><p>The basic workflow is to go into <code>deps/MFEM</code> directory. Then </p><ol><li>Make a new directory to add all source codes related to your custom operator.</li><li>Generate templated files using <code>customop</code>. </li><li>In your source code, do remember to include <code>../Common.h</code>, which exposes <code>mmesh</code> for all necessary data structures. </li><li>Add your source code file names to <code>deps/MFEM/CMakeLists.txt</code>.</li><li>Recompile PoreFlow or run <code>ninja</code> in <code>deps/MFEM/build</code>. </li><li>Test your code. Note you need to replace the library path in <code>load_op_and_grad</code> by <code>PoreFlow.libmfem</code> in order to share the same <code>mmesh</code> throughout the session. </li></ol><h2 id="Assembling-Matrices-and-Vectors"><a class="docs-heading-anchor" href="#Assembling-Matrices-and-Vectors">Assembling Matrices and Vectors</a><a id="Assembling-Matrices-and-Vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Assembling-Matrices-and-Vectors" title="Permalink"></a></h2><p>The main approach for assembling matrices and vectors in finite element methods is to loop over each element (triangles in our case), and computes contributions to the corresponding local degrees of freedom (DOF). For example, for P1 (linear) element, the local DOFs are three vertices; for P2 (quadratic) element, the local DOFs are both vertices and edges. </p><p><img src="../assets/mfem/dof.png" alt/></p><p>Each finite element (triangle) is represented by <code>NNFEM_Element</code> in the C++ shared library of PoreFlow. The local DOFs are mapped to global DOFs via <code>dof</code> array, which is a 6-dimensional array. For P1 element, the last three components are redundant. For P2 elements, the global indices are arranged in a way such that all edge indices are after the nodal indices. The mapping between edge indices and vertices can be found in <code>edges</code> in the structure <a href="../api/#PoreFlow.Mesh"><code>Mesh</code></a>. </p><p>When we loop over each element, each DOF is associated with a basis function <span>$\phi_i(x, y)$</span>, such that <span>$\phi_i(x_j, y_j) = \delta_{ij}$</span>, where <span>$(x_j, y_j)$</span> is the nodes shown in the above plots. For convenience, an element (<code>NNFEM_Element</code>) provides the values of </p><div>\[\phi_i(\tilde x_k, \tilde y_k), \partial_x \phi_i(\tilde x_k, \tilde y_k), \partial_y \phi_i(\tilde x_k, \tilde y_k), \tilde\phi_i(\tilde x_k, \tilde y_k) \tag{1}\]</div><p>Here <span>$(\tilde x_k, \tilde y_k)$</span> is the <span>$k$</span>-th Guass points for the current element, and <span>$\tilde \phi_i$</span> is the basis function for P1 element. The data are stored in <code>h</code>, <code>hx</code>, <code>hy</code>, <code>hs</code> respectively. Additionally, the element also contains a weight vector <code>w</code> that stores the quadrature weights (adjusted by triangle areas). Note Equation 1 are all <strong>physical</strong> shape functions. Therefore, we can conveniently compute many quantities. For example, if we want to compute <span>$\int_A \nabla u \cdot \nabla v dx dy$</span> on the element <span>$A$</span> (<span>$u$</span> is the trial function, and <span>$v$</span> is the test function), <span>$\int_A \nabla \phi_i \cdot \nabla \phi_j dxdy$</span> can be expressed as </p><pre><code class="language-c">double s = 0.0;
for (int r = 0; r &lt; elem-&gt;ngauss; r++){
    s += ( elem-&gt;hx(i, r) * elem-&gt;hx(j, r) + elem-&gt;hy(i, r) * elem-&gt;hy(j, r)) * elem-&gt;w(r);
}</code></pre><p>The corresponding indices in the global sparse matrix is </p><pre><code class="language-c">int I = elem-&gt;dof[i];
int J = elem-&gt;dof[j];`</code></pre><p>For the quadratic element, it has 6 DOFs for each element</p><p><img src="./assets/quadraticelem.png" alt/></p><p>Here <span>$x_{ij} = x_i - x_j$</span>, <span>$y_{ij} = y_i - y_j$</span>. We can use this information to assemble linear or bilinear forms. For example, in the course of implementing <a href="../api/#PoreFlow.compute_fem_traction_term1"><code>compute_fem_traction_term1</code></a>, we can first extract quadrature rules using </p><pre><code class="language-c">IntegrationRules rule_;
IntegrationRule rule = rule_.Get(Element::Type::SEGMENT, order);
const IntegrationPoint &amp;ip = rule.IntPoint(i)</code></pre><p>Then we have access to <code>ip.weight</code> and <code>ip.x</code>. </p><h2 id="Verifying-Implementation-against-FEniCS"><a class="docs-heading-anchor" href="#Verifying-Implementation-against-FEniCS">Verifying Implementation against FEniCS</a><a id="Verifying-Implementation-against-FEniCS-1"></a><a class="docs-heading-anchor-permalink" href="#Verifying-Implementation-against-FEniCS" title="Permalink"></a></h2><p>To test unstructured meshes, we can compare the results with <a href="https://fenicsproject.org/"><code>fenics</code></a>. We can use the same mesh:</p><pre><code class="language-julia">mesh = Mesh(8, 8, 1/8)</code></pre><p>The corresponding Python code is</p><pre><code class="language-python">mesh = UnitSquareMesh(8, 8, &quot;left&quot;)</code></pre><table><tr><th style="text-align: right">FEniCS</th><th style="text-align: right">PoreFlow</th></tr><tr><td style="text-align: right"><img src="../assets/mfem/mesh_fenics.png" alt/></td><td style="text-align: right"><img src="../assets/mfem/mesh_mfem.png" alt/></td></tr></table><p>As an example, in <code>deps/MFEM/ComputeInteractionTerm</code>, we developed a custom operator to compute <span>$\int_\Omega p \begin{bmatrix}\frac{\partial u}{\partial x} \\\frac{\partial u}{\partial y}\end{bmatrix} dx$</span> We can compute the values using FEniCS</p><pre><code class="language-python">from __future__ import print_function
from fenics import *
import matplotlib.pyplot as plt
import numpy as np 

# Create mesh and define function space
mesh = UnitSquareMesh(8, 8, &quot;left&quot;)
P = FunctionSpace(mesh, &#39;DG&#39;, 0)
U = FunctionSpace(mesh, &quot;CG&quot;, 1)

# Define variational problem
u = TrialFunction(U)
p = TestFunction(P)
a = dot(p, u.dx(0))*dx
b = dot(p, u.dx(1))*dx


A = assemble(a).array().T
x = np.random.random((A.shape[1],))
f = np.dot(A, x)
A1 = assemble(b).array().T
f1 = np.dot(A1, x)
DofToVert = vertex_to_dof_map(u.function_space())

np.savetxt(&quot;fenics/f.txt&quot;, np.concatenate([f[DofToVert], f1[DofToVert]]))
np.savetxt(&quot;fenics/x.txt&quot;, x)</code></pre><p>The corresponding Julia code is </p><pre><code class="language-julia">using ADCME
using LinearAlgebra
using PoreFlow
using DelimitedFiles

p = readdlm(&quot;fenics/x.txt&quot;)[:]
f = readdlm(&quot;fenics/f.txt&quot;)[:]

mesh = Mesh(8, 8, 1. /8)
f0 = compute_interaction_term(p, mesh)
sess = Session(); init(sess)
f1 = run(sess, f0)

@show norm(f - f1)</code></pre><p>We get the result:</p><pre><code class="language-none">norm(f - f1) = 3.0847790632031627e-16</code></pre><h2 id="Install-FEniCS"><a class="docs-heading-anchor" href="#Install-FEniCS">Install FEniCS</a><a id="Install-FEniCS-1"></a><a class="docs-heading-anchor-permalink" href="#Install-FEniCS" title="Permalink"></a></h2><p>It is recommend to install FEniCS by creating a new conda environment. For example, on a Linux server, you can do </p><pre><code class="language-bash">conda create -n fenicsproject -c conda-forge fenics
source activate fenicsproject</code></pre><p>Please refer to built-in PoreFlow custom operators to see how FEniCS is used for validation. </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../mfem_mesh/">« Construct Unstructured Meshes for PoreFlow</a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 28 September 2020 08:56">Monday 28 September 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
