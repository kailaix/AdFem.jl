<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · PoreFlow</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">PoreFlow</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">PoreFlow.jl Documentation</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../gallery/">PDE Galleries</a></li></ul></li><li><span class="tocitem">Forward Computation</span><ul><li><a class="tocitem" href="../coupled/">Coupled Geomechanics and Single Phase Flow</a></li><li><a class="tocitem" href="../staticelasticity/">Static Linear Elasticity</a></li><li><a class="tocitem" href="../plasticity/">Plasticity</a></li><li><a class="tocitem" href="../viscoelasticity/">Viscoelasticity</a></li><li><a class="tocitem" href="../viscoelasticity_earth/">Modeling Viscoelasticity of the Earth</a></li><li><a class="tocitem" href="../earthquake/">Earthquake Simulation with Rate-and-State Friction</a></li><li><a class="tocitem" href="../heatequation/">Heat Equation</a></li><li><a class="tocitem" href="../elastodynamics/">Elastodynamics</a></li><li><a class="tocitem" href="../twophaseflow/">Coupled Geomechanics and Multiphase Flow</a></li><li><a class="tocitem" href="../NavierStokes2/">Navier-Stokes equations</a></li><li><a class="tocitem" href="../SteadyStateNavierStokes/">Steady-state Navier-Stokes equations</a></li><li><a class="tocitem" href="../CHTCoupled/">Conjugate heat transfer coupled solver for incompressible fluid</a></li><li><a class="tocitem" href="../fwd_mixed_poisson/">Mixed Finite Element Methods for Poisson&#39;s Equation</a></li><li><a class="tocitem" href="../fwd_linear_elasticity/">Mixed Finite Element Methods for Linear Elasticity</a></li><li><a class="tocitem" href="../fwd_stress_based_viscoelasticity/">Mixed Finite Element Methods for Linear Viscoelasticity</a></li></ul></li><li><span class="tocitem">Inverse Modeling</span><ul><li><a class="tocitem" href="../inverse/">Inverse Modeling for Poroelasticity Models</a></li><li><a class="tocitem" href="../inv_viscoelasticity/">Inverse Modeling for Space Varying Viscoelasticity</a></li><li><a class="tocitem" href="../coupled_viscoelasticity/">Coupled Viscoelasticity and Single Phase Flow</a></li><li><a class="tocitem" href="../inv_twophaseflow/">Coupled Geomechanics and Multiphase Flow</a></li><li><a class="tocitem" href="../inv_viscoelasticity_nonparametric/">Inverse Modeling for Nonparametric Viscoelasticity</a></li><li><a class="tocitem" href="../inv_viscoelasticity_earth/">Viscoelasticity Model for the Earth</a></li></ul></li><li><span class="tocitem">Advanced Topics</span><ul><li><a class="tocitem" href="../mfem_tutorial/">Unstructured Meshes in PoreFlow</a></li><li><a class="tocitem" href="../mfem_mesh/">Construct Unstructured Meshes for PoreFlow</a></li><li><a class="tocitem" href="../dev_unstructured/">Adding Custom Operators for Unstructured Meshes</a></li><li><a class="tocitem" href="../BDMElement/">BDM Finite Element</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Data-Structures"><span>Data Structures</span></a></li><li><a class="tocitem" href="#Matrix-Assembling-Functions"><span>Matrix Assembling Functions</span></a></li><li><a class="tocitem" href="#Vector-Assembling-Functions"><span>Vector Assembling Functions</span></a></li><li><a class="tocitem" href="#Evaluation-Functions"><span>Evaluation Functions</span></a></li><li><a class="tocitem" href="#Boundary-Conditions"><span>Boundary Conditions</span></a></li><li><a class="tocitem" href="#Visualization"><span>Visualization</span></a></li><li><a class="tocitem" href="#Modeling-Tools"><span>Modeling Tools</span></a></li><li><a class="tocitem" href="#Mesh"><span>Mesh</span></a></li><li><a class="tocitem" href="#Misc"><span>Misc</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/kailaix/PoreFlow.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Data-Structures"><a class="docs-heading-anchor" href="#Data-Structures">Data Structures</a><a id="Data-Structures-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Structures" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.PoreData" href="#PoreFlow.PoreData"><code>PoreFlow.PoreData</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>PoreData</code> is a collection of physical parameters for coupled geomechanics and flow simulation</p><ul><li><code>M</code>: Biot modulus</li><li><code>b</code>: Biot coefficient</li><li><code>ρb</code>: Bulk density</li><li><code>ρf</code>: Fluid density</li><li><code>kp</code>: Permeability</li><li><code>E</code>: Young modulus</li><li><code>ν</code>: Poisson ratio</li><li><code>μ</code>: Fluid viscosity</li><li><code>Pi</code>: Initial pressure</li><li><code>Bf</code>: formation volume, <span>$B_f=\frac{\rho_{f,0}}{\rho_f}$</span></li><li><code>g</code>: Gravity acceleration</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.Mesh" href="#PoreFlow.Mesh"><code>PoreFlow.Mesh</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Mesh</code> holds data structures for an unstructured mesh. </p><ul><li><code>nodes</code>: a <span>$n_v \times 2$</span> coordinates array</li><li><code>edges</code>: a <span>$n_{\text{edge}} \times 2$</span> integer array for edges </li><li><code>elems</code>: a <span>$n_e \times 3$</span> connectivity matrix, 1-based. </li><li><code>nnode</code>, <code>nedge</code>, <code>nelem</code>: number of nodes, edges, and elements </li><li><code>ndof</code>: total number of degrees of freedoms </li><li><code>conn</code>: connectivity matrix, <code>nelems × 3</code> or <code>nelems × 6</code>, depending on whether a linear element or a quadratic element is used. </li><li><code>lorder</code>: order of quadrature rule for line integrals </li><li><code>elem_type</code>: type of the element (P1, P2 or BDM1)</li></ul><p>Internally, the mesh <code>mmesh</code> is represented by a collection of <code>NNFEM_Element</code> object with some other attributes</p><pre><code class="language-c">int nelem; // total number of elements
int nnode; // total number of nodes
int ngauss; // total number of Gauss points
int ndof; // total number of dofs
int order; // quadrature integration order
int degree; // Degree of Polynomials, 1 - P1 element, 2 - P2 element 
int elem_ndof; // 3 for P1, 6 for P2
MatrixXd GaussPts; // coordinates of Gauss quadrature points
std::vector&lt;NNFEM_Element*&gt; elements; // array of elements</code></pre><p>The <code>NNFEM_Element</code> has data</p><pre><code class="language-c">VectorXd h;   // basis functions, elem_ndof × ng  
VectorXd hx;  // x-directional basis functions, elem_ndof × ng  
VectorXd hy;  // y-directional basis functions, elem_ndof × ng  
MatrixXd hs;  // shape functions for linear element, 3 × ng
VectorXd w;   // weight vectors, ng  
double area;  // area of the triangle
MatrixXd coord; // coordinates array, 3 × 2
int nnode; // total number of nodes 
int ngauss; // total number of Gauss points
int dof[6]; // global indices for both nodes and edges, note that edge indices are offset by `nv`
int node[3]; // global indices of local vertices
int edge[3]; // global indices of local edges
int ndof; // DOF, 3 for P1 element, 6 for P2 element </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MFEM.jl#L13-L54">source</a></section></article><h2 id="Matrix-Assembling-Functions"><a class="docs-heading-anchor" href="#Matrix-Assembling-Functions">Matrix Assembling Functions</a><a id="Matrix-Assembling-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-Assembling-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.compute_fem_stiffness_matrix" href="#PoreFlow.compute_fem_stiffness_matrix"><code>PoreFlow.compute_fem_stiffness_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_stiffness_matrix(K::Array{Float64,2}, m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the term </p><div>\[\int_{A}\delta \varepsilon :\sigma\mathrm{d}x = \int_A u_AB^TKB\delta u_A\mathrm{d}x\]</div><p>where the constitutive relation is given by </p><div>\[\begin{bmatrix}\sigma_{xx}\\\sigma_{yy}\\\sigma_{xy}\end{bmatrix} = K \begin{bmatrix}\varepsilon_{xx}\\\varepsilon_{yy}\\2\varepsilon_{xy}\end{bmatrix}\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L41-L52">source</a></section><section><div><pre><code class="language-none">compute_fem_stiffness_matrix(hmat::PyObject,m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable kernel. <code>hmat</code> has one of the following sizes </p><ul><li><div>\[3\times 3\]</div></li><li><div>\[4mn \times 3 \times 3\]</div></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/InvCore.jl#L77-L83">source</a></section><section><div><pre><code class="language-none">compute_fem_stiffness_matrix(kappa::PyObject, mesh::Mesh)
compute_fem_stiffness_matrix(kappa::Array{Float64, 3}, mesh::Mesh)
compute_fem_stiffness_matrix(kappa::Array{Float64, 2}, mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MCore.jl#L242-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.compute_interaction_matrix" href="#PoreFlow.compute_interaction_matrix"><code>PoreFlow.compute_interaction_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_interaction_matrix(m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the interaction term </p><div>\[\int_A p \delta \varepsilon_v\mathrm{d}x = \int_A p [1,1,0]B^T\delta u_A\mathrm{d}x\]</div><p>Here <span>$\varepsilon_v = \text{tr}\; \varepsilon = \text{div}\; \mathbf{u}$</span>.</p><p>The output is a <span>$mn \times 2(m+1)(n+1)$</span> matrix. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L283-L293">source</a></section><section><div><pre><code class="language-none">compute_interaction_matrix(mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MCore.jl#L198-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.compute_fvm_tpfa_matrix" href="#PoreFlow.compute_fvm_tpfa_matrix"><code>PoreFlow.compute_fvm_tpfa_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fvm_tpfa_matrix(m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the term with two-point flux approximation </p><div>\[\int_{A_i} \Delta p \mathrm{d}x = \sum_{j=1}^{n_{\mathrm{faces}}} (p_j-p_i)\]</div><p><img src="../assets/tpfa.png" alt/></p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>No flow boundary condition is assumed. </p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L414-L425">source</a></section><section><div><pre><code class="language-none">compute_fvm_tpfa_matrix(K::Array{Float64}, m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the term with two-point flux approximation with distinct permeability at each cell</p><div>\[\int_{A_i} K_i \Delta p \mathrm{d}x = K_i\sum_{j=1}^{n_{\mathrm{faces}}} (p_j-p_i)\]</div><p>Note that <span>$K$</span> is a length <span>$mn$</span> vector, representing values per cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L449-L458">source</a></section><section><div><pre><code class="language-none">compute_fvm_tpfa_matrix(K::Array{Float64}, bc::Array{Int64,2}, pval::Array{Float64,1}, m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the term with two-point flux approximation with distinct permeability at each cell</p><div>\[\int_{A_i} K_i \Delta p \mathrm{d}x = K_i\sum_{j=1}^{n_{\mathrm{faces}}} (p_j-p_i)\]</div><p>Here <span>$K$</span> is a length <span>$mn$</span> vector, representing values per cell.</p><p>Additionally, Dirichlet boundary conditions are imposed on the boundary edges <code>bc</code> (a <span>$N\times 2$</span> integer matrix),  i.e., the <span>$i$</span>-th edge has value <code>pval</code>. The ghost node method is used for imposing the Dirichlet boundary condition.  The other boundaries are no-blow boundaries, i.e., <span>$\frac{\partial T}{\partial n} = 0$</span>.  The function outputs a length <span>$mn$</span> vector and <span>$mn\times mn$</span> matrix <span>$M$</span>. </p><div>\[\int_{A_i} K_i \Delta p \mathrm{d}x = f_i + M_{i,:}\mathbf{p}\]</div><p>Returns both the sparse matrix <code>A</code> and the right hand side <code>rhs</code>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p><code>K</code> can also be missing, in which case <code>K</code> is treated as a all-one vector. </p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L481-L503">source</a></section><section><div><pre><code class="language-none">compute_fvm_tpfa_matrix(K::PyObject, bc::Array{Int64,2}, pval::Union{Array{Float64},PyObject}, m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable kernel for <a href="#PoreFlow.compute_fvm_tpfa_matrix"><code>compute_fvm_tpfa_matrix</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/InvCore.jl#L213-L217">source</a></section><section><div><pre><code class="language-none">compute_fvm_tpfa_matrix(K::PyObject, m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable kernel for <a href="#PoreFlow.compute_fvm_tpfa_matrix"><code>compute_fvm_tpfa_matrix</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/InvCore.jl#L235-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.compute_fem_mass_matrix" href="#PoreFlow.compute_fem_mass_matrix"><code>PoreFlow.compute_fem_mass_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_mass_matrix(m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the finite element mass matrix </p><div>\[\int_{\Omega} u \delta u \mathrm{d}x\]</div><p>The matrix size is <span>$2(m+1)(n+1) \times 2(m+1)(n+1)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L916-L926">source</a></section><section><div><pre><code class="language-none">compute_fem_mass_matrix(ρ::PyObject,m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable kernel. <span>$\rho$</span> is a vector of length <span>$4mn$</span> or <span>$8mn$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/InvCore.jl#L365-L369">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.compute_fvm_mass_matrix" href="#PoreFlow.compute_fvm_mass_matrix"><code>PoreFlow.compute_fvm_mass_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fvm_mass_matrix(m::Int64, n::Int64, h::Float64)</code></pre><p>Returns the FVM mass matrix </p><div>\[\int_{A_i} p_i \mathrm{d}x = h^2 p_i \]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L1084-L1091">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.compute_fem_mass_matrix1" href="#PoreFlow.compute_fem_mass_matrix1"><code>PoreFlow.compute_fem_mass_matrix1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_mass_matrix1(ρ::Array{Float64,1}, m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the mass matrix for a scalar value <span>$u$</span></p><div>\[\int_A \rho u \delta u \mathrm{d} x\]</div><p>The output is a <span>$(m+1)(n+1)\times (m+1)(n+1)$</span> sparse matrix. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L853-L861">source</a></section><section><div><pre><code class="language-none">compute_fem_mass_matrix1(m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the mass matrix for a scalar value <span>$u$</span></p><div>\[\int_A u \delta u \mathrm{d} x\]</div><p>The output is a <span>$(m+1)(n+1)\times (m+1)(n+1)$</span> sparse matrix. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L902-L910">source</a></section><section><div><pre><code class="language-none">compute_fem_mass_matrix1(ρ::PyObject,m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable kernel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/InvCore.jl#L352-L356">source</a></section><section><div><pre><code class="language-none">compute_fem_mass_matrix1(rho::Union{PyObject, Array{Float64, 1}}, mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MCore.jl#L159-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.compute_fem_stiffness_matrix1" href="#PoreFlow.compute_fem_stiffness_matrix1"><code>PoreFlow.compute_fem_stiffness_matrix1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_stiffness_matrix1(K::Array{Float64,2}, m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the term </p><div>\[\int_{A} (K \nabla u) \cdot \nabla \delta u \mathrm{d}x = \int_A u_A B^T K B \delta u_A\mathrm{d}x\]</div><p>Returns a <span>$(m+1)\times (n+1)$</span> matrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L89-L97">source</a></section><section><div><pre><code class="language-none">compute_fem_stiffness_matrix1(hmat::PyObject, m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable kernel for computing the stiffness matrix.  Two possible shapes for <code>hmat</code> are supported: </p><ul><li><div>\[4mn \times 2\times 2\]</div></li><li><div>\[2 \times 2\]</div></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/InvCore.jl#L57-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.compute_fvm_advection_matrix" href="#PoreFlow.compute_fvm_advection_matrix"><code>PoreFlow.compute_fvm_advection_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fvm_advection_matrix(v::Union{PyObject, Array{Float64, 2}},
    bc::Array{Int64, 2},bcval::Union{PyObject, Array{Float64}},m::Int64,n::Int64,h::Float64)</code></pre><p>Computes the advection matrix for use in the implicit scheme </p><div>\[\int_A \mathbf{v} \cdot \nabla u dx \]</div><p>Here <code>v</code> is a <span>$2mn$</span> vector, where the first <span>$mn$</span> entries corresponds to the first dimension of   <span>$\mathbf{v}$</span> and the remaining <span>$mn$</span> entries corresponds to the second dimension. </p><p>It returns a matrix <span>$mn\times mn$</span> matrix <span>$K$</span> and an auxilliary term <span>$\mathbf{f}$</span> due to boundary conditions.</p><div>\[\int_\Omega \mathbf{v} \cdot \nabla u dx = K \mathbf{u} + \mathbf{f}\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/InvCore.jl#L268-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.compute_fem_laplace_matrix1" href="#PoreFlow.compute_fem_laplace_matrix1"><code>PoreFlow.compute_fem_laplace_matrix1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_laplace_matrix1(K::Array{Float64, 1}, m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the coefficient matrix for </p><div>\[\int_\Omega K \nabla u \cdot \nabla (\delta u) \; dx \]</div><p>Here <span>$K\in \mathbf{R}^{2\times 2}$</span>, <span>$u$</span> is a scalar variable, and <code>K</code> is a <span>$4mn \times 2 \times 2$</span> matrix. </p><p>Returns a <span>$(m+1)(n+1)\times (m+1)(n+1)$</span> sparse matrix. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L1182-L1193">source</a></section><section><div><pre><code class="language-none">compute_fem_laplace_matrix1(K::Array{Float64, 2}, m::Int64, n::Int64, h::Float64)</code></pre><p><code>K</code> is duplicated on each Gauss point. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L1238-L1242">source</a></section><section><div><pre><code class="language-none">compute_fem_laplace_matrix1(K::Array{Float64, 1}, m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the coefficient matrix for </p><div>\[\int_\Omega K\nabla u \cdot \nabla (\delta u) \; dx \]</div><p>Here <code>K</code> is a vector with length <span>$4mn$</span> (defined on Gauss points). </p><p>Returns a <span>$(m+1)(n+1)\times (m+1)(n+1)$</span> sparse matrix. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L1251-L1263">source</a></section><section><div><pre><code class="language-none">compute_fem_laplace_matrix1(m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the coefficient matrix for </p><div>\[\int_\Omega \nabla u \cdot \nabla (\delta u) \; dx \]</div><p>Returns a <span>$(m+1)(n+1)\times (m+1)(n+1)$</span> sparse matrix. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L1273-L1283">source</a></section><section><div><pre><code class="language-none">compute_fem_laplace_matrix1(K::PyObject, m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable kernel. Only <span>$K\in \mathbb{R}^{4mn}$</span> is supported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/InvCore.jl#L438-L442">source</a></section><section><div><pre><code class="language-none">compute_fem_laplace_matrix1(kappa::PyObject, mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MCore.jl#L91-L93">source</a></section><section><div><pre><code class="language-none">compute_fem_laplace_matrix1(kappa::Array{Float64,1}, mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MCore.jl#L103-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.compute_fem_laplace_matrix" href="#PoreFlow.compute_fem_laplace_matrix"><code>PoreFlow.compute_fem_laplace_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_laplace_matrix(m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the coefficient matrix for </p><div>\[\int_\Omega \nabla \mathbf{u} \cdot \nabla (\delta \mathbf{u}) \; dx \]</div><p>Here</p><div>\[\mathbf{u}  = \begin{bmatrix} u \\ v \end{bmatrix}\]</div><p>and </p><div>\[\nabla \mathbf{u} = \begin{bmatrix}u_x &amp; u_y \\ v_x &amp; v_y \end{bmatrix}\]</div><p>Returns a <span>$2(m+1)(n+1)\times 2(m+1)(n+1)$</span> sparse matrix. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L1293-L1311">source</a></section><section><div><pre><code class="language-none">compute_fem_laplace_matrix(K::Array{Float64, 1}, m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the coefficient matrix for </p><div>\[\int_\Omega K \nabla \mathbf{u} \cdot \nabla (\delta \mathbf{u}) \; dx \]</div><p>Here <span>$K$</span> is a scalar defined on Gauss points. <code>K</code> is a vector of length <span>$4mn$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L1318-L1328">source</a></section><section><div><pre><code class="language-none">compute_fem_laplace_matrix(kappa::Union{PyObject, Array{Float64, 1}}, mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MCore.jl#L116-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.compute_fem_advection_matrix1" href="#PoreFlow.compute_fem_advection_matrix1"><code>PoreFlow.compute_fem_advection_matrix1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_advection_matrix1(u0::PyObject,v0::PyObject,m::Int64,n::Int64,h::Float64)</code></pre><p>Computes the advection term for a scalar function <span>$u$</span> defined on an FEM grid. The weak form is </p><div>\[\int_\Omega (\mathbf{u}_0 \cdot \nabla u)  \delta u \; d\mathbf{x} = \int_\Omega \left(u_0 \frac{\partial u}{\partial x} \delta u + v_0 \frac{\partial u}{\partial y}  \delta u\right)\; d\mathbf{x}\]</div><p>Here <span>$u_0$</span> and <span>$v_0$</span> are both vectors of length <span>$4mn$</span>. </p><p>Returns a sparse matrix of size <span>$(m+1)(n+1)\times (m+1)(n+1)$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/InvCore.jl#L400-L410">source</a></section><section><div><pre><code class="language-none">compute_fem_advection_matrix1(u::Union{Array{Float64,1}, PyObject},v::Union{Array{Float64,1}, PyObject}, mesh::Mesh)
compute_fem_advection_matrix1(u::Array{Float64,1}, v::Array{Float64,1}, mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MCore.jl#L171-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.compute_fem_bdm_mass_matrix" href="#PoreFlow.compute_fem_bdm_mass_matrix"><code>PoreFlow.compute_fem_bdm_mass_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_bdm_mass_matrix(alpha::Union{Array{Float64,1}, PyObject},beta::Union{Array{Float64,1}, PyObject}, mmesh::Mesh)</code></pre><p>Computes </p><div>\[\int_\Omega A\sigma : \delta \tau dx\]</div><p>Here </p><div>\[A\sigma = \alpha \sigma + \beta \text{tr} \sigma I\]</div><div>\[\sigma\]</div><p>and <span>$\tau$</span> are both fourth-order tensors. The output is a  <code>4mmesh.nedge × 4mmesh.nedge</code> matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MBDM.jl#L41-L53">source</a></section><section><div><pre><code class="language-none">compute_fem_bdm_mass_matrix(mmesh::Mesh)</code></pre><p>Same as <a href="#PoreFlow.compute_fem_bdm_mass_matrix"><code>compute_fem_bdm_mass_matrix</code></a>, except that </p>$$</div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MBDM.jl#L62-L68">source</a></section><section><div><pre><code class="language-none">compute_fem_bdm_mass_matrix(alpha::Array{Float64,1},beta::Array{Float64,1}, mmesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MBDM.jl#L75-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.compute_fem_bdm_mass_matrix1" href="#PoreFlow.compute_fem_bdm_mass_matrix1"><code>PoreFlow.compute_fem_bdm_mass_matrix1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_bdm_mass_matrix1(alpha::Array{Float64,1}, mmesh::Mesh)</code></pre><p>Computes </p><div>\[\int_\Omega \alpha\sigma \cdot \delta \tau dx\]</div><p>Here <span>$\alpha$</span> is a scalar, and <span>$\sigma$</span> and <span>$\delta \tau$</span> are second order tensors. </p><p>The returned value is a <code>2mmesh.nedge × 2mmesh.nedge</code> matrix. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MBDM.jl#L91-L101">source</a></section><section><div><pre><code class="language-none">compute_fem_bdm_mass_matrix1(mmesh::Mesh)</code></pre><p>Same as <a href="#PoreFlow.compute_fem_bdm_mass_matrix1"><code>compute_fem_bdm_mass_matrix1</code></a>, except that <span>$\alpha\equiv 1$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MBDM.jl#L113-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.compute_fem_bdm_div_matrix" href="#PoreFlow.compute_fem_bdm_div_matrix"><code>PoreFlow.compute_fem_bdm_div_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_bdm_div_matrix(mmesh::Mesh)</code></pre><p>Computes the coefficient matrix for </p><div>\[\int_\Omega \text{div} \tau \delta u dx\]</div><p>Here <span>$\tau \in \mathbb{R}^{2\times 2}$</span> is a fourth-order tensor (not necessarily symmetric). <code>mmesh</code>  uses the BDM1 finite element. The output is a <code>2mmesh.nelem × 4mmesh.nedge</code> matrix. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MBDM.jl#L25-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.compute_fem_bdm_div_matrix1" href="#PoreFlow.compute_fem_bdm_div_matrix1"><code>PoreFlow.compute_fem_bdm_div_matrix1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_bdm_div_matrix1(mmesh::Mesh)</code></pre><p>Computes the coefficient matrix for </p><div>\[\int_\Omega \text{div} \tau \delta u dx\]</div><p>Here <span>$\tau \in \mathbb{R}^{2}$</span> is a second-order tensor (not necessarily symmetric). <code>mmesh</code>  uses the BDM1 finite element. The output is a <code>mmesh.nelem × 2mmesh.nedge</code> matrix. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MBDM.jl#L5-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.compute_fem_bdm_skew_matrix" href="#PoreFlow.compute_fem_bdm_skew_matrix"><code>PoreFlow.compute_fem_bdm_skew_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_bdm_skew_matrix(mmesh::Mesh)</code></pre><p>Computes  <span>$\int_\Omega \sigma : v dx$</span> where </p><div>\[v = \begin{bmatrix}0 &amp; \rho \\-\rho &amp; 0 \end{bmatrix}\]</div><p>Here <span>$\sigma$</span> is a fourth-order tensor. </p><p>The returned value is a <code>mmesh.nelem × 4mmesh.nedge</code> matrix. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MBDM.jl#L123-L135">source</a></section></article><h2 id="Vector-Assembling-Functions"><a class="docs-heading-anchor" href="#Vector-Assembling-Functions">Vector Assembling Functions</a><a id="Vector-Assembling-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Vector-Assembling-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.compute_fem_source_term" href="#PoreFlow.compute_fem_source_term"><code>PoreFlow.compute_fem_source_term</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_source_term(f1::Array{Float64}, f2::Array{Float64},
m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the term </p><div>\[\int_\Omega \mathbf{f}\cdot\delta u \mathrm{d}x\]</div><p>Returns a <span>$2(m+1)(n+1)$</span> vector. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L133-L142">source</a></section><section><div><pre><code class="language-none">compute_fem_source_term(f1::PyObject, f2::PyObject,
m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable kernel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/InvCore.jl#L314-L319">source</a></section><section><div><pre><code class="language-none">compute_fem_source_term(f1::Union{PyObject,Array{Float64,2}}, f2::Union{PyObject,Array{Float64,2}}, mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MCore.jl#L82-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.compute_fvm_source_term" href="#PoreFlow.compute_fvm_source_term"><code>PoreFlow.compute_fvm_source_term</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fvm_source_term(f::Array{Float64}, m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the source term </p><div>\[\int_{A_i} f\mathrm{d}x\]</div><p>Here <span>$f$</span> has length <span>$4mn$</span> or <span>$mn$</span>. In the first case, an average value of four quadrature nodal values of <span>$f$</span> is used per cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L335-L343">source</a></section><section><div><pre><code class="language-none">compute_fvm_source_term(f::PyObject, m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable kernel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/InvCore.jl#L385-L389">source</a></section><section><div><pre><code class="language-none">compute_fvm_source_term(f::Array{Float64, 1}, mmesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MCore.jl#L667-L669">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.compute_fvm_mechanics_term" href="#PoreFlow.compute_fvm_mechanics_term"><code>PoreFlow.compute_fvm_mechanics_term</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fvm_mechanics_term(u::Array{Float64}, m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the mechanic interaction term </p><div>\[\int_{A_i} \varepsilon_v\mathrm{d}x\]</div><p>Here </p><div>\[\varepsilon_v = \mathrm{tr} \varepsilon = \varepsilon_{xx} + \varepsilon_{yy}\]</div><p>Numerically, we have </p><div>\[\varepsilon_v = [1 \ 1 \ 0] B^T \delta u_A\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L359-L374">source</a></section><section><div><pre><code class="language-none">compute_fvm_mechanics_term(u::PyObject, m::Int64, n::Int64, h::Float64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L404-L406">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.compute_fem_normal_traction_term" href="#PoreFlow.compute_fem_normal_traction_term"><code>PoreFlow.compute_fem_normal_traction_term</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_normal_traction_term(t::Array{Float64,1}, bdedge::Array{Int64},
m::Int64, n::Int64, h::Float64)
compute_fem_normal_traction_term(t::Float64, bdedge::Array{Int64},
m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the normal traction term </p><div>\[\int_{\Gamma} t(\mathbf{n})\cdot\delta u \mathrm{d}\]</div><p>Here <span>$t(\mathbf{n})\parallel\mathbf{n}$</span> points <strong>outward</strong> to the domain and the magnitude is given by <code>t</code>.  <code>bdedge</code> is a <span>$N\times2$</span> matrix and each row denotes the indices of two endpoints of the boundary edge. </p><p>See <a href="#PoreFlow.compute_fem_traction_term"><code>compute_fem_traction_term</code></a> for graphical illustration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L629-L643">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.compute_fem_traction_term" href="#PoreFlow.compute_fem_traction_term"><code>PoreFlow.compute_fem_traction_term</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_traction_term(t::Array{Float64, 2},
bdedge::Array{Int64,2}, m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the traction term </p><div>\[\int_{\Gamma} t(\mathbf{n})\cdot\delta u \mathrm{d}\]</div><p>The number of rows of <code>t</code> is equal to the number of edges in <code>bdedge</code>.  The first component of <code>t</code> describes the <span>$x$</span> direction traction, while the second  component of <code>t</code> describes the <span>$y$</span> direction traction. </p><p>Also see <a href="#PoreFlow.compute_fem_normal_traction_term"><code>compute_fem_normal_traction_term</code></a>. </p><p><img src="../assets/traction.png" alt/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L548-L564">source</a></section><section><div><pre><code class="language-none">compute_fem_traction_term(t::Array{Float64, 2},
bdedge::Array{Int64,2}, mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MCore.jl#L535-L538">source</a></section><section><div><pre><code class="language-none">compute_fem_traction_term(t1::Array{Float64, 1}, t2::Array{Float64, 1},
bdedge::Array{Int64,2}, mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MCore.jl#L546-L549">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.compute_von_mises_stress_term" href="#PoreFlow.compute_von_mises_stress_term"><code>PoreFlow.compute_von_mises_stress_term</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_von_mises_stress_term(K::Array{Float64}, u::Array{Float64}, m::Int64, n::Int64, h::Float64)</code></pre><p>Compute the <a href="https://en.wikipedia.org/wiki/Von_Mises_yield_criterion#Multi-axial_(2D_or_3D)_stress">von Mises stress</a> on the Gauss quadrature nodes. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L798-L802">source</a></section><section><div><pre><code class="language-none">compute_von_mises_stress_term(Se::Array{Float64,2},  m::Int64, n::Int64, h::Float64)</code></pre><p><code>Se</code> is a <span>$4mn\times3$</span> array that stores the stress data at each Gauss point. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L838-L842">source</a></section><section><div><pre><code class="language-none">compute_von_mises_stress_term(K::Array{Float64, 3}, u::Array{Float64, 1}, mesh::Mesh)
compute_von_mises_stress_term(K::Array{Float64, 2}, u::Array{Float64, 1}, mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MCore.jl#L598-L601">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.compute_fem_source_term1" href="#PoreFlow.compute_fem_source_term1"><code>PoreFlow.compute_fem_source_term1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_source_term1(f::Array{Float64},
m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the term </p><div>\[\int_\Omega f \delta u dx\]</div><p>Returns a <span>$(m+1)\times (n+1)$</span> vector. <code>f</code> is a length <span>$4mn$</span> vector, given by its values on Gauss points. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L176-L185">source</a></section><section><div><pre><code class="language-none">compute_fem_source_term1(f::PyObject,
m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable kernel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/InvCore.jl#L300-L305">source</a></section><section><div><pre><code class="language-none">compute_fem_source_term1(f::PyObject, mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MCore.jl#L60-L62">source</a></section><section><div><pre><code class="language-none">compute_fem_source_term1(f::Array{Float64,1}, mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MCore.jl#L72-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.compute_fem_flux_term1" href="#PoreFlow.compute_fem_flux_term1"><code>PoreFlow.compute_fem_flux_term1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_flux_term1(t::Array{Float64},
bdedge::Array{Int64,2}, m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the traction term </p><div>\[\int_{\Gamma} q \delta u \mathrm{d}\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L608-L616">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.compute_strain_energy_term" href="#PoreFlow.compute_strain_energy_term"><code>PoreFlow.compute_strain_energy_term</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_strain_energy_term(S::Array{Float64, 2}, m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the strain energy </p><div>\[\int_{A} \sigma : \delta \varepsilon \mathrm{d}x\]</div><p>where <span>$\sigma$</span> is provided by <code>S</code>, a <span>$4mn \times 3$</span> matrix.  The values <span>$\sigma_{11}, \sigma_{22}, \sigma_{12}$</span> are defined on 4 Gauss points per element. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L1097-L1106">source</a></section><section><div><pre><code class="language-none">compute_strain_energy_term(S::PyObject,m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable kernel. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/InvCore.jl#L112-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.compute_strain_energy_term1" href="#PoreFlow.compute_strain_energy_term1"><code>PoreFlow.compute_strain_energy_term1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_strain_energy_term1(S::PyObject, m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the strain energy </p><div>\[\int_{A} \sigma : \delta \varepsilon \mathrm{d}x\]</div><p>where <span>$\sigma$</span> is provided by <code>S</code>, a <span>$4mn \times 2$</span> matrix.  The values <span>$\sigma_{31}, \sigma_{32}$</span> are defined on 4 Gauss points per element. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L1140-L1149">source</a></section><section><div><pre><code class="language-none">compute_strain_energy_term1(sigma::PyObject, m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable  operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/InvCore.jl#L125-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.compute_fem_viscoelasticity_strain_energy_term" href="#PoreFlow.compute_fem_viscoelasticity_strain_energy_term"><code>PoreFlow.compute_fem_viscoelasticity_strain_energy_term</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_viscoelasticity_strain_energy_term(ε0, σ0, ε, A, B, m, n, h)</code></pre><p>Given the constitutive relation</p><div>\[\sigma^{n+1} = S \sigma^n + H (\varepsilon^{n+1}-\varepsilon^n),\]</div><p>this function computes </p><div>\[\int_A {\sigma:\delta \varepsilon}\mathrm{d} x = \underbrace{\int_A { B \varepsilon^{n+1}:\delta \varepsilon}\mathrm{d} x}  + \underbrace{ \int_A { A \sigma^{n+1}:\delta \varepsilon}\mathrm{d} x - \int_A { B \varepsilon^{n+1}:\delta \varepsilon}\mathrm{d} x }_f\]</div><p>and returns <span>$f$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Viscoelasticity.jl#L3-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.compute_fvm_advection_term" href="#PoreFlow.compute_fvm_advection_term"><code>PoreFlow.compute_fvm_advection_term</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fvm_advection_term(v::Union{PyObject, Array{Float64, 2}},
u::Union{PyObject, Array{Float64,1}},m::Int64,n::Int64,h::Float64)</code></pre><p>Computes the advection term using upwind schemes</p><div>\[\int_A \mathbf{v} \cdot \nabla u dx \]</div><p>Here <span>$\mathbf{v}$</span> is a <span>$mn\times 2$</span> matrix and <span>$u$</span> is a length <span>$mn$</span> vector. Zero boundary conditions are assumed.  <span>$u$</span> is a vector of length <span>$m\times n$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/InvCore.jl#L249-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.compute_interaction_term" href="#PoreFlow.compute_interaction_term"><code>PoreFlow.compute_interaction_term</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_interaction_term(p::Array{Float64, 1}, m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the FVM-FEM interaction term </p><div>\[ \begin{bmatrix} \int p \frac{\partial \delta u}{\partial x} dx \\  \int p \frac{\partial \delta v}{\partial y}  dy \end{bmatrix} \]</div><p>The input is a vector of length <span>$mn$</span>. The output is a <span>$2(m+1)(n+1)$</span> vector. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L1398-L1408">source</a></section><section><div><pre><code class="language-none">compute_interaction_term(p::PyObject, m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable kernel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/InvCore.jl#L451-L455">source</a></section><section><div><pre><code class="language-none">compute_interaction_term(p::Union{PyObject,Array{Float64, 1}}, mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MCore.jl#L149-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.compute_fem_laplace_term1" href="#PoreFlow.compute_fem_laplace_term1"><code>PoreFlow.compute_fem_laplace_term1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_laplace_term1(u::PyObject,κ::PyObject,m::Int64,n::Int64,h::Float64)
compute_fem_laplace_term1(u::PyObject,m::Int64,n::Int64,h::Float64)
compute_fem_laplace_term1(u::Array{Float64},κ::PyObject, m::Int64,n::Int64,h::Float64)
compute_fem_laplace_term1(u::PyObject,κ::Array{Float64}, m::Int64,n::Int64,h::Float64)</code></pre><p>Computes the Laplace term for a scalar function <span>$u$</span></p><div>\[\int_\Omega K\nabla u \cdot \nabla (\delta u) \mathrm{d}x\]</div><p>Here <code>κ</code> is a vector of length <span>$4mn$</span>, and <code>u</code> is a vector of length <span>$(m+1)(n+1)$</span>. </p><p>When <code>κ</code> is not provided, the following term is calculated:</p><div>\[\int_\Omega \nabla u \cdot \nabla (\delta u) \mathrm{d}x\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/InvCore.jl#L464-L483">source</a></section><section><div><pre><code class="language-none">compute_fem_laplace_term1(u::Array{Float64, 1},nu::Array{Float64, 1}, mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MCore.jl#L627-L629">source</a></section><section><div><pre><code class="language-none">compute_fem_laplace_term1(u::Union{PyObject, Array{Float64, 1}},
                            nu::Union{PyObject, Array{Float64, 1}},
                            mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MCore.jl#L639-L643">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.compute_fem_traction_term1" href="#PoreFlow.compute_fem_traction_term1"><code>PoreFlow.compute_fem_traction_term1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_traction_term1(t::Array{Float64, 2},
bdedge::Array{Int64,2}, m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the traction term </p><div>\[\int_{\Gamma} t(n) \delta u \mathrm{d}\]</div><p>The number of rows of <code>t</code> is equal to the number of edges in <code>bdedge</code>.  The output is a length <span>$(m+1)*(n+1)$</span> vector. </p><p>Also see <a href="#PoreFlow.compute_fem_traction_term"><code>compute_fem_traction_term</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L581-L594">source</a></section><section><div><pre><code class="language-none">compute_fem_traction_term1(t::Array{Float64, 1},
bdedge::Array{Int64,2}, mesh::Mesh)</code></pre><p>Computes the boundary integral </p><div>\[\int_{\Gamma} t(x, y) \delta u dx\]</div><p>Returns a vector of size <code>dof</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MCore.jl#L471-L480">source</a></section></article><h2 id="Evaluation-Functions"><a class="docs-heading-anchor" href="#Evaluation-Functions">Evaluation Functions</a><a id="Evaluation-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.eval_f_on_gauss_pts" href="#PoreFlow.eval_f_on_gauss_pts"><code>PoreFlow.eval_f_on_gauss_pts</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval_f_on_gauss_pts(f::Function, m::Int64, n::Int64, h::Float64; tensor_input::Bool = false)</code></pre><p>Evaluates <code>f</code> at Gaussian points and return the result as <span>$4mn$</span> vector <code>out</code> (4 Gauss points per element)</p><p>If <code>tensor_input = true</code>, the function <code>f</code> is assumed to map a tensor to a tensor output.</p><p><img src="./assets/gauss.png" alt/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L934-L942">source</a></section><section><div><pre><code class="language-none">eval_f_on_gauss_pts(f::Function, mesh::Mesh; tensor_input::Bool = false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MCore.jl#L3-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.eval_f_on_dof_pts" href="#PoreFlow.eval_f_on_dof_pts"><code>PoreFlow.eval_f_on_dof_pts</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval_f_on_dof_pts(f::Function, mesh::Mesh)</code></pre><p>Evaluates <code>f</code> on the DOF points. </p><ul><li>For P1 element, the DOF points are FEM points and therefore <code>eval_f_on_dof_pts</code> is equivalent to <code>eval_on_on_fem_pts</code>.</li><li>For P2 element, the DOF points are FEM points plus the middle point for each edge. </li></ul><p>Returns a vector of length <code>mesh.ndof</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MCore.jl#L37-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.eval_f_on_boundary_node" href="#PoreFlow.eval_f_on_boundary_node"><code>PoreFlow.eval_f_on_boundary_node</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval_f_on_boundary_node(f::Function, bdnode::Array{Int64}, m::Int64, n::Int64, h::Float64)</code></pre><p>Returns a vector of the same length as <code>bdnode</code> whose entries corresponding to <code>bdnode</code> nodes are filled with values computed from <code>f</code>.</p><p><code>f</code> has the following signature </p><pre><code class="language-none">f(x::Float64, y::Float64)::Float64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L985-L995">source</a></section><section><div><pre><code class="language-none">eval_f_on_boundary_node(f::Function, bdnode::Array{Int64}, mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MCore.jl#L579-L581">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.eval_f_on_boundary_edge" href="#PoreFlow.eval_f_on_boundary_edge"><code>PoreFlow.eval_f_on_boundary_edge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval_f_on_boundary_edge(f::Function, bdedge::Array{Int64,2}, m::Int64, n::Int64, h::Float64)</code></pre><p>Returns a vector of the same length as <code>bdedge</code> whose entries corresponding to <code>bdedge</code> nodes are filled with values computed from <code>f</code>.</p><p><code>f</code> has the following signature </p><pre><code class="language-none">f(x::Float64, y::Float64)::Float64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L1005-L1015">source</a></section><section><div><pre><code class="language-none">eval_f_on_boundary_edge(f::Function, bdedge::Array{Int64, 2}, mesh::Mesh; tensor_input::Bool = false)</code></pre><p>Evaluates <code>f</code> on the boundary <strong>Gauss points</strong>. Here <code>f</code> has the signature</p><p><code>f(Float64, Float64)::Float64</code></p><p>or </p><p><code>f(PyObject, PyObject)::PyObject</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MCore.jl#L557-L567">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.eval_strain_on_gauss_pts" href="#PoreFlow.eval_strain_on_gauss_pts"><code>PoreFlow.eval_strain_on_gauss_pts</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval_strain_on_gauss_pts(u::Array{Float64}, m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the strain on Gauss points.  Returns a <span>$4mn\times3$</span> matrix, where each row denotes <span>$(\varepsilon_{11}, \varepsilon_{22}, 2\varepsilon_{12})$</span> at the corresponding Gauss point. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L1028-L1034">source</a></section><section><div><pre><code class="language-none">eval_strain_on_gauss_pts(u::PyObject, m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable kernel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/InvCore.jl#L137-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.eval_strain_on_gauss_pts1" href="#PoreFlow.eval_strain_on_gauss_pts1"><code>PoreFlow.eval_strain_on_gauss_pts1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval_strain_on_gauss_pts1(u::PyObject, m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable kernel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/InvCore.jl#L153-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.eval_f_on_fvm_pts" href="#PoreFlow.eval_f_on_fvm_pts"><code>PoreFlow.eval_f_on_fvm_pts</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval_f_on_fvm_pts(f::Function, m::Int64, n::Int64, h::Float64; tensor_input::Bool = false)</code></pre><p>Returns <span>$f(x_i, y_i)$</span> where <span>$(x_i,y_i)$</span> are FVM nodes. </p><p>If <code>tensor_input = true</code>, the function <code>f</code> is assumed to map a tensor to a tensor output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L968-L974">source</a></section><section><div><pre><code class="language-none">eval_f_on_fvm_pts(f::Function, mesh::Mesh; tensor_input::Bool = false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MCore.jl#L26-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.eval_f_on_fem_pts" href="#PoreFlow.eval_f_on_fem_pts"><code>PoreFlow.eval_f_on_fem_pts</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval_f_on_fem_pts(f::Function, m::Int64, n::Int64, h::Float64; tensor_input::Bool = false)</code></pre><p>Returns <span>$f(x_i, y_i)$</span> where <span>$(x_i,y_i)$</span> are FEM nodes. </p><p>If <code>tensor_input = true</code>, the function <code>f</code> is assumed to map a tensor to a tensor output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L952-L958">source</a></section><section><div><pre><code class="language-none">eval_f_on_fem_pts(f::Function, mesh::Mesh; tensor_input::Bool = false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MCore.jl#L15-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.eval_grad_on_gauss_pts1" href="#PoreFlow.eval_grad_on_gauss_pts1"><code>PoreFlow.eval_grad_on_gauss_pts1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval_grad_on_gauss_pts1(u::Array{Float64,1}, m::Int64, n::Int64, h::Float64)</code></pre><p>Evaluates <span>$\nabla u$</span> on each Gauss point. Here <span>$u$</span> is a scalar function. </p><p>The input <code>u</code> is a vector of length <span>$(m+1)*(n+1)$</span>. The output is a matrix of size <span>$4mn\times 2$</span>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L1337-L1344">source</a></section><section><div><pre><code class="language-none">eval_grad_on_gauss_pts1(u::PyObject, m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable kernel. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/InvCore.jl#L326-L330">source</a></section><section><div><pre><code class="language-none">eval_grad_on_gauss_pts1(u::Union{Array{Float64,1}, PyObject}, mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MCore.jl#L212-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.eval_grad_on_gauss_pts" href="#PoreFlow.eval_grad_on_gauss_pts"><code>PoreFlow.eval_grad_on_gauss_pts</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval_grad_on_gauss_pts(u::Array{Float64,1}, m::Int64, n::Int64, h::Float64)</code></pre><p>Evaluates <span>$\nabla u$</span> on each Gauss point. Here <span>$\mathbf{u} = (u, v)$</span>.</p><div>\[\texttt{g[i,:,:]} = \begin{bmatrix} u_x &amp; u_y\\ v_x &amp; v_y \end{bmatrix}\]</div><p>The input <code>u</code> is a vector of length <span>$2(m+1)*(n+1)$</span>. The output is a matrix of size <span>$4mn\times 2 \times 2$</span>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L1377-L1386">source</a></section><section><div><pre><code class="language-none">eval_grad_on_gauss_pts(u::PyObject, m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable kernel. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/InvCore.jl#L339-L343">source</a></section></article><h2 id="Boundary-Conditions"><a class="docs-heading-anchor" href="#Boundary-Conditions">Boundary Conditions</a><a id="Boundary-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-Conditions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.fem_impose_Dirichlet_boundary_condition" href="#PoreFlow.fem_impose_Dirichlet_boundary_condition"><code>PoreFlow.fem_impose_Dirichlet_boundary_condition</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fem_impose_Dirichlet_boundary_condition(A::SparseMatrixCSC{Float64,Int64}, 
bd::Array{Int64}, m::Int64, n::Int64, h::Float64)</code></pre><p>Imposes the Dirichlet boundary conditions on the matrix <code>A</code>.</p><p>Returns 2 matrix, </p><div>\[\begin{bmatrix}
A_{BB} &amp; A_{BI} \\ 
A_{IB} &amp; A_{II} 
\end{bmatrix} \Rightarrow \begin{bmatrix}
I &amp; 0 \\ 
0 &amp; A_{II} 
\end{bmatrix}, \quad \begin{bmatrix}
0 \\ 
A_{IB} 
\end{bmatrix}\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L208-L227">source</a></section><section><div><pre><code class="language-none">fem_impose_Dirichlet_boundary_condition(L::SparseTensor, bdnode::Array{Int64}, m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable kernel for imposing the Dirichlet boundary of a vector-valued function. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/InvCore.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.fem_impose_Dirichlet_boundary_condition1" href="#PoreFlow.fem_impose_Dirichlet_boundary_condition1"><code>PoreFlow.fem_impose_Dirichlet_boundary_condition1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fem_impose_Dirichlet_boundary_condition1(A::SparseMatrixCSC{Float64,Int64}, 
    bd::Array{Int64}, m::Int64, n::Int64, h::Float64)</code></pre><p>Imposes the Dirichlet boundary conditions on the matrix <code>A</code> Returns 2 matrix, </p><div>\[\begin{bmatrix}
A_{BB} &amp; A_{BI} \\ 
A_{IB} &amp; A_{II} 
\end{bmatrix} \Rightarrow \begin{bmatrix}
I &amp; 0 \\ 
0 &amp; A_{II} 
\end{bmatrix}, \quad \begin{bmatrix}
0 \\ 
A_{IB} 
\end{bmatrix}\]</div><p><code>bd</code> must NOT have duplicates. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L251-L271">source</a></section><section><div><pre><code class="language-none">fem_impose_Dirichlet_boundary_condition1(L::SparseTensor, bdnode::Array{Int64}, m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable kernel for imposing the Dirichlet boundary of a scalar-valued function. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/InvCore.jl#L26-L30">source</a></section><section><div><pre><code class="language-none">fem_impose_Dirichlet_boundary_condition1(L::SparseTensor, bdnode::Array{Int64}, mesh::Mesh)</code></pre><p>A differentiable kernel for imposing the Dirichlet boundary of a scalar-valued function. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MCore.jl#L134-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.impose_Dirichlet_boundary_conditions" href="#PoreFlow.impose_Dirichlet_boundary_conditions"><code>PoreFlow.impose_Dirichlet_boundary_conditions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">impose_Dirichlet_boundary_conditions(A::Union{SparseArrays, Array{Float64, 2}}, rhs::Array{Float64,1}, bdnode::Array{Int64, 1}, 
    bdval::Array{Float64,1})
impose_Dirichlet_boundary_conditions(A::SparseTensor, rhs::Union{Array{Float64,1}, PyObject}, bdnode::Array{Int64, 1}, 
    bdval::Union{Array{Float64,1}, PyObject})</code></pre><p>Algebraically impose the Dirichlet boundary conditions. We want the solutions at indices <code>bdnode</code> to be <code>bdval</code>. Given the matrix and the right hand side</p><div>\[\begin{bmatrix} A_{II} &amp; A_{IB} \\ A_{BI} &amp; A_{BB} \end{bmatrix}, \begin{bmatrix}r_I \\ r_B \end{bmatrix}\]</div><p>The function returns</p><div>\[\begin{bmatrix} A_{II} &amp; 0 \\ 0 &amp; I \end{bmatrix}, \begin{bmatrix}r_I - A_{IB} u_B \\ r_B \end{bmatrix}\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MUtils.jl#L97-L110">source</a></section></article><h2 id="Visualization"><a class="docs-heading-anchor" href="#Visualization">Visualization</a><a id="Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization" title="Permalink"></a></h2><p>In <code>visualize_scalar_on_XXX_points</code>, the first argument is the data matrix. When the data matrix is 1D, one snapshot is plotted. When the data matrix is 2D, it is understood as multiple snapshots at different time steps (each row is a snapshot). When the data matrix is 3D, it is understood as <code>time step × height × width</code>. </p><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.visualize_mesh" href="#PoreFlow.visualize_mesh"><code>PoreFlow.visualize_mesh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">visualize_mesh(mesh::Mesh)</code></pre><p>Visualizes the unstructured meshes. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MVisualize.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.visualize_pressure" href="#PoreFlow.visualize_pressure"><code>PoreFlow.visualize_pressure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">visualize_pressure(U::Array{Float64, 2}, m::Int64, n::Int64, h::Float64)</code></pre><p>Visualizes pressure. <code>U</code> is the solution vector. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Visualization.jl#L7-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.visualize_displacement" href="#PoreFlow.visualize_displacement"><code>PoreFlow.visualize_displacement</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">visualize_displacement(u::Array{Float64, 2}, m::Int64, n::Int64, h::Float64)</code></pre><p>Generates scattered plot animation for displacement <span>$u\in \mathbb{R}^{(NT+1)\times 2(m+1)(n+1)}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Visualization.jl#L333-L337">source</a></section><section><div><pre><code class="language-none">visualize_displacement(u::Array{Float64, 1}, mmesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MVisualize.jl#L108-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.visualize_stress" href="#PoreFlow.visualize_stress"><code>PoreFlow.visualize_stress</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">visualize_stress(K::Array{Float64, 2}, U::Array{Float64, 2}, m::Int64, n::Int64, h::Float64; name::String=&quot;&quot;)</code></pre><p>Visualizes displacement. <code>U</code> is the solution vector, <code>K</code> is the elasticity matrix (<span>$3\times 3$</span>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Visualization.jl#L65-L70">source</a></section><section><div><pre><code class="language-none">visualize_stress(Se::Array{Float64, 2}, m::Int64, n::Int64, h::Float64; name::String=&quot;&quot;)</code></pre><p>Visualizes the Von Mises stress. <code>Se</code> is the Von Mises at the cell center. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Visualization.jl#L126-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.visualize_von_mises_stress" href="#PoreFlow.visualize_von_mises_stress"><code>PoreFlow.visualize_von_mises_stress</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">visualize_von_mises_stress(Se::Array{Float64, 2}, m::Int64, n::Int64, h::Float64; name::String=&quot;&quot;)</code></pre><p>Visualizes the Von Mises stress. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Visualization.jl#L186-L190">source</a></section><section><div><pre><code class="language-none">visualize_von_mises_stress(K::Array{Float64}, u::Array{Float64, 1}, mmesh::Mesh, args...; kwargs...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MVisualize.jl#L118-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.visualize_scalar_on_gauss_points" href="#PoreFlow.visualize_scalar_on_gauss_points"><code>PoreFlow.visualize_scalar_on_gauss_points</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">visualize_scalar_on_gauss_points(u::Array{Float64,1}, m::Int64, n::Int64, h::Float64, args...;kwargs...)</code></pre><p>Visualizes the scalar <code>u</code> using pcolormesh. Here <code>u</code> is a length <span>$4mn$</span> vector and the values are defined on the Gauss points</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Visualization.jl#L413-L417">source</a></section><section><div><pre><code class="language-none">visualize_scalar_on_gauss_points(u::Array{Float64,1}, mesh::Mesh, args...;kwargs...)</code></pre><p>Visualizes scalar values on Gauss points. For unstructured meshes, the values on each element are averaged to produce a uniform value for each element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MVisualize.jl#L71-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.visualize_scalar_on_fem_points" href="#PoreFlow.visualize_scalar_on_fem_points"><code>PoreFlow.visualize_scalar_on_fem_points</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">visualize_scalar_on_fem_points(u::Array{Float64,1}, m::Int64, n::Int64, h::Float64, args...;kwargs...)</code></pre><p>Visualizes the scalar <code>u</code> using pcolormesh. Here <code>u</code> is a length <span>$(m+1)(n+1)$</span> vector and the values are defined on the FEM points</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Visualization.jl#L517-L521">source</a></section><section><div><pre><code class="language-none">visualize_scalar_on_fem_points(u::Array{Float64,2}, m::Int64, n::Int64, h::Float64, args...;kwargs...)</code></pre><p>Visualizes the scalar <code>u</code> using pcolormesh. Here <code>u</code> is a matrix of size <span>$NT \times (m+1)(n+1)$</span> (<span>$NT$</span> is the number of time steps) and the values are defined on the FEM points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Visualization.jl#L541-L545">source</a></section><section><div><pre><code class="language-none">visualize_scalar_on_fem_points(u::Array{Float64,1}, mesh::Mesh, args...;
    with_mesh::Bool = false, kwargs...)</code></pre><p>Visualizes the nodal values <code>u</code> on the unstructured mesh <code>mesh</code>.</p><ul><li><code>with_mesh</code>: if true, the unstructured mesh is also plotted. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MVisualize.jl#L24-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.visualize_scalar_on_fvm_points" href="#PoreFlow.visualize_scalar_on_fvm_points"><code>PoreFlow.visualize_scalar_on_fvm_points</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">visualize_scalar_on_fvm_points(φ::Array{Float64, 3}, m::Int64, n::Int64, h::Float64;
vmin::Union{Real, Missing} = missing, vmax::Union{Real, Missing} = missing)</code></pre><p>Generates scattered potential animation for the potential <span>$\phi\in \mathbb{R}^{(NT+1)\times n \times m}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Visualization.jl#L261-L266">source</a></section><section><div><pre><code class="language-none">visualize_scalar_on_fvm_points(u::Array{Float64,1}, mesh::Mesh, args...;kwargs...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MVisualize.jl#L87-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.visualize_vector_on_fem_points" href="#PoreFlow.visualize_vector_on_fem_points"><code>PoreFlow.visualize_vector_on_fem_points</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">visualize_vector_on_fem_points(u1::Array{Float64,1}, u2::Array{Float64,1}, mesh::Mesh, args...;kwargs...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MVisualize.jl#L126-L128">source</a></section></article><h2 id="Modeling-Tools"><a class="docs-heading-anchor" href="#Modeling-Tools">Modeling Tools</a><a id="Modeling-Tools-1"></a><a class="docs-heading-anchor-permalink" href="#Modeling-Tools" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.layer_model" href="#PoreFlow.layer_model"><code>PoreFlow.layer_model</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">layer_model(u::Array{Float64, 1}, m::Int64, n::Int64, h::Float64)</code></pre><p>Convert the vertical profile of a quantity to a layer model.  The input <code>u</code> is a length <span>$n$</span> vector, the output is a length <span>$4mn$</span> vector, representing the <span>$4mn$</span> Gauss points. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Utils.jl#L47-L52">source</a></section><section><div><pre><code class="language-none">layer_model(u::PyObject, m::Int64, n::Int64, h::Float64)</code></pre><p>A differential kernel for <a href="#PoreFlow.layer_model"><code>layer_model</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Utils.jl#L58-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.compute_vel" href="#PoreFlow.compute_vel"><code>PoreFlow.compute_vel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_vel(a::Union{PyObject, Array{Float64, 1}},
v0::Union{PyObject, Float64},psi::Union{PyObject, Array{Float64, 1}},
sigma::Union{PyObject, Array{Float64, 1}},
tau::Union{PyObject, Array{Float64, 1}},eta::Union{PyObject, Float64})</code></pre><p>Computes <span>$x = u_3(x_1, x_2)$</span> from rate and state friction. The governing equation is </p><div>\[a \sinh^{-1}\left( \frac{x - u}{\Delta t} \frac{1}{2V_0} e^{\frac{\Psi}{a}} \right) \sigma - \tau + \eta \frac{x-u}{\Delta t} = 0\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/InvCore.jl#L168-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.compute_plane_strain_matrix" href="#PoreFlow.compute_plane_strain_matrix"><code>PoreFlow.compute_plane_strain_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_plane_strain_matrix(E::Float64, ν::Float64)</code></pre><p>Computes the stiffness matrix for 2D plane strain. The matrix is given by </p><div>\[\frac{E(1-\nu)}{(1+\nu)(1-2\nu)}\begin{bmatrix}
1 &amp; \frac{\nu}{1-\nu} &amp; \frac{\nu}{1-\nu}\\ 
\frac{\nu}{1-\nu} &amp; 1 &amp; \frac{\nu}{1-\nu} \\ 
\frac{\nu}{1-\nu} &amp; \frac{\nu}{1-\nu} &amp; 1
\end{bmatrix}\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L730-L740">source</a></section><section><div><pre><code class="language-none">compute_plane_strain_matrix(E::Union{PyObject, Array{Float64, 1}}, nu::Union{PyObject, Array{Float64, 1}})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L770-L772">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.compute_plane_stress_matrix" href="#PoreFlow.compute_plane_stress_matrix"><code>PoreFlow.compute_plane_stress_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_plane_stress_matrix(E::Float64, ν::Float64)</code></pre><p>Computes the stiffness matrix for 2D plane stress. The matrix is given by </p><div>\[\frac{E}{(1+\nu)(1-2\nu)}\begin{bmatrix}
1-\nu &amp; \nu &amp; 0\\ 
\nu &amp; 1 &amp; 0 \\ 
0 &amp; 0 &amp; \frac{1-2\nu}{2}
\end{bmatrix}\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L750-L760">source</a></section><section><div><pre><code class="language-none">compute_plane_stress_matrix(E::Union{PyObject, Array{Float64, 1}}, nu::Union{PyObject, Array{Float64, 1}})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L783-L785">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.compute_space_varying_tangent_elasticity_matrix" href="#PoreFlow.compute_space_varying_tangent_elasticity_matrix"><code>PoreFlow.compute_space_varying_tangent_elasticity_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_space_varying_tangent_elasticity_matrix(mu::Union{PyObject, Array{Float64,1}},m::Int64,n::Int64,h::Float64,type::Int64=1)</code></pre><p>Computes the space varying tangent elasticity matrix given <span>$\mu$</span>. It returns a matrix of size <span>$4mn\times 2\times 2$</span></p><ul><li>If <code>type==1</code>, the <span>$i$</span>-th matrix will be </li></ul><div>\[\begin{bmatrix}\mu_i &amp; 0 \\ 0 &amp; \mu_i \end{bmatrix}\]</div><ul><li>If <code>type==2</code>, the <span>$i$</span>-th matrix will be </li></ul><div>\[\begin{bmatrix}\mu_i &amp; 0 \\ 0 &amp; \mu_{i+4mn} \end{bmatrix}\]</div><ul><li>If <code>type==3</code>, the <span>$i$</span>-th matrix will be </li></ul><div>\[\begin{bmatrix}\mu_i &amp; \mu_{i+8mn} \\ \mu_{i+8mn} &amp; \mu_{i+4mn}\end{bmatrix}\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/InvCore.jl#L188-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.mantle_viscosity" href="#PoreFlow.mantle_viscosity"><code>PoreFlow.mantle_viscosity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mantle_viscosity(u::Union{Array{Float64}, PyObject},
    T::Union{Array{Float64}, PyObject}, m::Int64, n::Int64, h::Float64;
    σ_yield::Union{Float64, PyObject} = 300e6, 
    ω::Union{Float64, PyObject}, 
    η_min::Union{Float64, PyObject} = 1e18, 
    η_max::Union{Float64, PyObject} = 1e23, 
    E::Union{Float64, PyObject} = 9.0, 
    C::Union{Float64, PyObject} = 1000., N::Union{Float64, PyObject} = 2.)</code></pre><div>\[\eta = \eta_{\min} + \min\left( \frac{\sigma_{\text{yield}}}{2\sqrt{\epsilon_{II}}}, \omega\min(\eta_{\max}, \eta) \right)\]</div><p>with  </p><div>\[\epsilon_{II} = \frac{1}{2} \epsilon(u)\qquad \eta = C e^{E(0.5-T)} (\epsilon_{II})^{(1-n)/2n}\]</div><p>Here <span>$\epsilon_{II}$</span> is the second invariant of the strain rate tensor, <span>$C &gt; 0$</span> is a viscosity pre-factor, <span>$E &gt; 0$</span> is the non-dimensional activation energy, <span>$n &gt; 0$</span> is the nonlinear exponent, <span>$η_\min$</span>, <span>$η_\max$</span> act as minimum and maximum bounds for the effective viscosity, and <span>$σ_{\text{yield}} &gt; 0$</span> is the yield stress. <span>$w\in (0, 1]$</span> is the weakening factor, which is used to incorporate phenomenological aspects that cannot be represented in a purely viscous flow model, such as processes which govern mega-thrust faults along the subduction interface, or partial melting near a mid-ocean ridge.</p><p>The viscosity of the mantle is governed by the high-temperature creep of silicates, for which laboratory experiments show that the creep strength is temperature-, pressure-, compositional- and stress-dependent. </p><p>The output is a length <span>$4mn$</span> vector. </p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>See <strong>Towards adjoint-based inversion of time-dependent mantle convection with nonlinear viscosity</strong> for details.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Constitutive.jl#L25-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.antiplane_viscosity" href="#PoreFlow.antiplane_viscosity"><code>PoreFlow.antiplane_viscosity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">antiplane_viscosity(ε::Union{PyObject, Array{Float64}}, σ::Union{PyObject, Array{Float64}}, 
μ::Union{PyObject, Float64}, η::Union{PyObject, Float64}, Δt::Float64)</code></pre><p>Calculates the stress at time <span>$t_{n+1}$</span> given the strain at <span>$t_{n+1}$</span> and stress at <span>$t_{n}$</span>. The governing equation is </p><div>\[\dot\sigma + \frac{\mu}{\eta}\sigma = 2\mu \dot\epsilon\]</div><p>The discretization form is </p><div>\[\sigma^{n+1} = \frac{1}{\frac{1}{\Delta t}+\frac{\mu}{\eta}}(2\mu\dot\epsilon^{n+1} + \frac{\sigma^n}{\Delta t})\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Constitutive.jl#L2-L14">source</a></section></article><h2 id="Mesh"><a class="docs-heading-anchor" href="#Mesh">Mesh</a><a id="Mesh-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.get_edge_dof" href="#PoreFlow.get_edge_dof"><code>PoreFlow.get_edge_dof</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_edge_dof(edges::Array{Int64, 2}, mesh::Mesh)
get_edge_dof(edges::Array{Int64, 1}, mesh::Mesh)</code></pre><p>Returns the DOFs for <code>edges</code>, which is a <code>K × 2</code> array containing vertex indices.  The DOFs are not offset by <code>nnode</code>, i.e., the smallest edge DOF could be 1. </p><p>When the input is a length 2 vector, it returns a single index for the corresponding edge DOF. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MUtils.jl#L67-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.get_boundary_edge_orientation" href="#PoreFlow.get_boundary_edge_orientation"><code>PoreFlow.get_boundary_edge_orientation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_boundary_edge_orientation(bdedge::Array{Int64, 2}, mmesh::Mesh)</code></pre><p>Returns the orientation of the edges in <code>bdedge</code>. For example, if for a boundary element <code>[1,2,3]</code>, assume <code>[1,2]</code> is the boundary edge,  then </p><pre><code class="language-none">get_boundary_edge_orientation([1 2;2 1], mmesh) = [1.0;-1.0]</code></pre><p>The return values for non-boundary edges in <code>bdedge</code> is undefined. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MUtils.jl#L186-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.get_area" href="#PoreFlow.get_area"><code>PoreFlow.get_area</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_ngauss(mesh::Mesh)</code></pre><p>Return the areas of triangles as an array. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MFEM.jl#L206-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.get_ngauss" href="#PoreFlow.get_ngauss"><code>PoreFlow.get_ngauss</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_ngauss(mesh::Mesh)</code></pre><p>Return the total number of Gauss points. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MFEM.jl#L197-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.bcnode" href="#PoreFlow.bcnode"><code>PoreFlow.bcnode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bcnode(desc::String, m::Int64, n::Int64, h::Float64)</code></pre><p>Returns the node indices for the description. Multiple descriptions can be concatented via <code>|</code></p><pre><code class="language-none">                upper
        |------------------|
left    |                  | right
        |                  |
        |__________________|

                lower</code></pre><p><strong>Example</strong></p><pre><code class="language-julia">bcnode(&quot;left|upper&quot;, m, n, h)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Utils.jl#L117-L136">source</a></section><section><div><pre><code class="language-none">bcnode(mesh::Mesh; by_dof::Bool = true)</code></pre><p>Returns all boundary node indices. </p><p>If <code>by_dof = true</code>, <code>bcnode</code> returns the global indices for boundary DOFs. </p><ul><li>For <code>P2</code> elements, the returned values are boundary node DOFs + boundary edge DOFs (offseted by <code>mesh.nnode</code>)</li><li>For <code>BDM1</code> elements, the returned values are boundary edge DOFs + boundary edge DOFs offseted by <code>mesh.nedge</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MCore.jl#L397-L406">source</a></section><section><div><pre><code class="language-none">bcnode(f::Function, mesh::Mesh; by_dof::Bool = true)</code></pre><p>Returns the boundary node DOFs that satisfies <code>f(x,y) = true</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For BDM1 element and <code>by_dof = true</code>, because the degrees of freedoms are associated with edges, <code>f</code> has the signature</p><pre><code class="language-julia">f(x1::Float64, y1::Float64, x2::Float64, y2::Float64)::Bool</code></pre><p><code>bcnode</code> only returns DOFs on edges such that <code>f(x1, y1, x2, y2)=true</code>. </p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MCore.jl#L420-L435">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.bcedge" href="#PoreFlow.bcedge"><code>PoreFlow.bcedge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bcedge(desc::String, m::Int64, n::Int64, h::Float64)</code></pre><p>Returns the edge indices for description. See <a href="#PoreFlow.bcnode"><code>bcnode</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Utils.jl#L96-L100">source</a></section><section><div><pre><code class="language-none">bcedge(mesh::Mesh)</code></pre><p>Returns all boundary edges as a set of integer pairs (edge vertices).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MCore.jl#L348-L352">source</a></section><section><div><pre><code class="language-none">bcedge(f::Function, mesh::Mesh)</code></pre><p>Returns all edge indices that satisfies <code>f(x1, y1, x2, y2) = true</code> Here the edge endpoints are given by <span>$(x_1, y_1)$</span> and <span>$(x_2, y_2)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MCore.jl#L376-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.interior_node" href="#PoreFlow.interior_node"><code>PoreFlow.interior_node</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">interior_node(desc::String, m::Int64, n::Int64, h::Float64)</code></pre><p>In contrast to <a href="#PoreFlow.bcnode"><code>bcnode</code></a>, <code>interior_node</code> returns the nodes that are not specified by <code>desc</code>, including thosee on the boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Utils.jl#L168-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.femidx" href="#PoreFlow.femidx"><code>PoreFlow.femidx</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">femidx(d::Int64, m::Int64)</code></pre><p>Returns the FEM index of the dof <code>d</code>. Basically, <code>femidx</code> is the inverse of </p><pre><code class="language-none">(i,j) → d = (j-1)*(m+1) + i</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Utils.jl#L6-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.fvmidx" href="#PoreFlow.fvmidx"><code>PoreFlow.fvmidx</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fvmidx(d::Int64, m::Int64)</code></pre><p>Returns the FVM index of the dof <code>d</code>. Basically, <code>femidx</code> is the inverse of </p><pre><code class="language-none">(i,j) → d = (j-1)*m + i</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Utils.jl#L22-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.subdomain" href="#PoreFlow.subdomain"><code>PoreFlow.subdomain</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">subdomain(f::Function, m::Int64, n::Int64, h::Float64)</code></pre><p>Returns the subdomain defined by <code>f(x, y)==true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Utils.jl#L289-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.gauss_nodes" href="#PoreFlow.gauss_nodes"><code>PoreFlow.gauss_nodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gauss_nodes(m::Int64, n::Int64, h::Float64)</code></pre><p>Returns the node matrix of Gauss points for all elements. The matrix has a size <span>$4mn\times 2$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Utils.jl#L200-L204">source</a></section><section><div><pre><code class="language-none">gauss_nodes(mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MFEM.jl#L218-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.gauss_weights" href="#PoreFlow.gauss_weights"><code>PoreFlow.gauss_weights</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gauss_weights(mmesh::Mesh)</code></pre><p>Returns the weights for each Gauss points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MCore.jl#L655-L659">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.fem_nodes" href="#PoreFlow.fem_nodes"><code>PoreFlow.fem_nodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fem_nodes(m::Int64, n::Int64, h::Float64)</code></pre><p>Returns the FEM node matrix of size <span>$(m+1)(n+1)\times 2$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Utils.jl#L227-L231">source</a></section><section><div><pre><code class="language-none">fem_nodes(mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MFEM.jl#L229-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.fvm_nodes" href="#PoreFlow.fvm_nodes"><code>PoreFlow.fvm_nodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fvm_nodes(m::Int64, n::Int64, h::Float64)</code></pre><p>Returns the FVM node matrix of size <span>$(m+1)(n+1)\times 2$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Utils.jl#L247-L251">source</a></section><section><div><pre><code class="language-none">fvm_nodes(mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MFEM.jl#L236-L238">source</a></section></article><h2 id="Misc"><a class="docs-heading-anchor" href="#Misc">Misc</a><a id="Misc-1"></a><a class="docs-heading-anchor-permalink" href="#Misc" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.trim_coupled" href="#PoreFlow.trim_coupled"><code>PoreFlow.trim_coupled</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">trim_coupled(pd::PoreData, Q::SparseMatrixCSC{Float64,Int64}, L::SparseMatrixCSC{Float64,Int64}, 
M::SparseMatrixCSC{Float64,Int64}, 
bd::Array{Int64}, Δt::Float64, m::Int64, n::Int64, h::Float64)</code></pre><p>Assembles matrices from mechanics and flow and assemble the coupled matrix </p><div>\[\begin{bmatrix}
\hat M &amp; -\hat L^T\\
\hat L &amp; \hat Q
\end{bmatrix}\]</div><p><code>Q</code> is obtained from <a href="#PoreFlow.compute_fvm_tpfa_matrix"><code>compute_fvm_tpfa_matrix</code></a>, <code>M</code> is obtained from <a href="#PoreFlow.compute_fem_stiffness_matrix"><code>compute_fem_stiffness_matrix</code></a>, and <code>L</code> is obtained from <a href="#PoreFlow.compute_interaction_matrix"><code>compute_interaction_matrix</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L666-L681">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.coupled_impose_pressure" href="#PoreFlow.coupled_impose_pressure"><code>PoreFlow.coupled_impose_pressure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">coupled_impose_pressure(A::SparseMatrixCSC{Float64,Int64}, pnode::Array{Int64}, 
m::Int64, n::Int64, h::Float64)</code></pre><p>Returns a trimmed matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Core.jl#L700-L705">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.cholesky_factorize" href="#PoreFlow.cholesky_factorize"><code>PoreFlow.cholesky_factorize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cholesky_factorize(A::Union{Array{&lt;:Real,2}, PyObject})</code></pre><p>Returns the cholesky factor of <code>A</code>. See <a href="#PoreFlow.cholesky_outproduct"><code>cholesky_outproduct</code></a> for details. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Utils.jl#L320-L324">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.cholesky_outproduct" href="#PoreFlow.cholesky_outproduct"><code>PoreFlow.cholesky_outproduct</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cholesky_outproduct(L::Union{Array{&lt;:Real,2}, PyObject})</code></pre><p>Returns  <span>$A = LL&#39;$</span> where <code>L</code> (length=6) is a vectorized form of <span>$L$</span> <span>$L = \begin{matrix} l_1 &amp; 0 &amp; 0\\  l_4 &amp; l_2 &amp; 0 \\  l_5 &amp; l_6 &amp; l_3 \end{matrix}$</span> and <code>A</code> (length=9) is also a vectorized form of <span>$A$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Utils.jl#L300-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.fem_to_fvm" href="#PoreFlow.fem_to_fvm"><code>PoreFlow.fem_to_fvm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fem_to_fvm(u::Union{PyObject, Array{Float64}}, m::Int64, n::Int64, h::Float64)</code></pre><p>Interpolates the nodal values of <code>u</code> to cell values. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Utils.jl#L179-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.fem_to_gauss_points" href="#PoreFlow.fem_to_gauss_points"><code>PoreFlow.fem_to_gauss_points</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fem_to_gauss_points(u::PyOject, m::Int64, n::Int64, h::Float64)
fem_to_gauss_points(u::Array{Float64,1}, m::Int64, n::Int64, h::Float64)</code></pre><p>Given a vector of length <span>$(m+1)(n+1)$</span>, <code>u</code>, returns the function values at each Gauss point. </p><p>Returns a vector of length <span>$4mn$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/Utils.jl#L345-L352">source</a></section><section><div><pre><code class="language-none">fem_to_gauss_points(u::PyObject, mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MUtils.jl#L141-L143">source</a></section><section><div><pre><code class="language-none">fem_to_gauss_points(u::Array{Float64,1}, mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MUtils.jl#L151-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoreFlow.dof_to_gauss_points" href="#PoreFlow.dof_to_gauss_points"><code>PoreFlow.dof_to_gauss_points</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dof_to_gauss_points(u::PyObject, mesh::Mesh)
dof_to_gauss_points(u::Array{Float64,1}, mesh::Mesh)</code></pre><p>Similar to <a href="#PoreFlow.fem_to_gauss_points"><code>fem_to_gauss_points</code></a>. The only difference is that the function uses all DOFs–-which means,  for quadratic elements, the nodal values on the edges are also used. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/PoreFlow.jl/blob/8d4c7f6c8903afd9e7836e81b4084b23203bc058/src/MFEM/MUtils.jl#L162-L168">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../BDMElement/">« BDM Finite Element</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 12 October 2020 22:12">Monday 12 October 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
