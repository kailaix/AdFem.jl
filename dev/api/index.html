<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · AdFem</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="AdFem logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">AdFem</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">AdFem.jl Documentation</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../gallery/">PDE Galleries</a></li></ul></li><li><span class="tocitem">Forward Computation</span><ul><li><a class="tocitem" href="../coupled/">Coupled Geomechanics and Single Phase Flow</a></li><li><a class="tocitem" href="../staticelasticity/">Static Linear Elasticity</a></li><li><a class="tocitem" href="../plasticity/">Plasticity</a></li><li><a class="tocitem" href="../viscoelasticity/">Viscoelasticity</a></li><li><a class="tocitem" href="../viscoelasticity_earth/">Modeling Viscoelasticity of the Earth</a></li><li><a class="tocitem" href="../earthquake/">Earthquake Simulation with Rate-and-State Friction</a></li><li><a class="tocitem" href="../heatequation/">Heat Equation</a></li><li><a class="tocitem" href="../elastodynamics/">Elastodynamics</a></li><li><a class="tocitem" href="../twophaseflow/">Coupled Geomechanics and Multiphase Flow</a></li><li><a class="tocitem" href="../NavierStokes2/">Navier-Stokes equations</a></li><li><a class="tocitem" href="../SteadyStateNavierStokes/">Steady-state Navier-Stokes equations</a></li><li><a class="tocitem" href="../SteadyStateNavierStokes3D/">Steady-state Navier-Stokes equations in 3D space</a></li><li><a class="tocitem" href="../CHTCoupled/">Conjugate heat transfer coupled solver for incompressible fluid</a></li><li><a class="tocitem" href="../fwd_mixed_poisson/">Mixed Finite Element Methods for Poisson&#39;s Equation</a></li><li><a class="tocitem" href="../fwd_linear_elasticity/">Mixed Finite Element Methods for Linear Elasticity</a></li><li><a class="tocitem" href="../fwd_stress_based_viscoelasticity/">Mixed Finite Element Methods for Linear Viscoelasticity</a></li><li><a class="tocitem" href="../pml/">Perfectly Matched Layer</a></li></ul></li><li><span class="tocitem">Inverse Modeling</span><ul><li><a class="tocitem" href="../inverse/">Inverse Modeling for Poroelasticity Models</a></li><li><a class="tocitem" href="../inv_viscoelasticity/">Inverse Modeling for Space Varying Viscoelasticity</a></li><li><a class="tocitem" href="../coupled_viscoelasticity/">Coupled Viscoelasticity and Single Phase Flow</a></li><li><a class="tocitem" href="../inv_twophaseflow/">Coupled Geomechanics and Multiphase Flow</a></li><li><a class="tocitem" href="../inv_viscoelasticity_nonparametric/">Inverse Modeling for Nonparametric Viscoelasticity</a></li><li><a class="tocitem" href="../inv_viscoelasticity_earth/">Viscoelasticity Model for the Earth</a></li></ul></li><li><span class="tocitem">Advanced Topics</span><ul><li><a class="tocitem" href="../mfem_tutorial/">Unstructured Meshes in AdFem</a></li><li><a class="tocitem" href="../mfem_mesh/">Construct Unstructured Meshes for AdFem</a></li><li><a class="tocitem" href="../dev_unstructured/">Adding Custom Operators for Unstructured Meshes</a></li><li><a class="tocitem" href="../BDMElement/">BDM Finite Element</a></li><li><a class="tocitem" href="../mfem3d/">Working with 3D Domains</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Data-Structures"><span>Data Structures</span></a></li><li><a class="tocitem" href="#Matrix-Assembling-Functions"><span>Matrix Assembling Functions</span></a></li><li><a class="tocitem" href="#Vector-Assembling-Functions"><span>Vector Assembling Functions</span></a></li><li><a class="tocitem" href="#Evaluation-Functions"><span>Evaluation Functions</span></a></li><li><a class="tocitem" href="#Boundary-Conditions"><span>Boundary Conditions</span></a></li><li><a class="tocitem" href="#Visualization"><span>Visualization</span></a></li><li><a class="tocitem" href="#Modeling-Tools"><span>Modeling Tools</span></a></li><li><a class="tocitem" href="#Mesh"><span>Mesh</span></a></li><li><a class="tocitem" href="#Physics-Constrained-Learning"><span>Physics Constrained Learning</span></a></li><li><a class="tocitem" href="#Misc"><span>Misc</span></a></li></ul></li><li><a class="tocitem" href="../docker_install_guide/">Install &amp; Reproduce AdFem With Docker Guide</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/kailaix/AdFem.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Data-Structures"><a class="docs-heading-anchor" href="#Data-Structures">Data Structures</a><a id="Data-Structures-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Structures" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="AdFem.PoreData" href="#AdFem.PoreData"><code>AdFem.PoreData</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>PoreData</code> is a collection of physical parameters for coupled geomechanics and flow simulation</p><ul><li><code>M</code>: Biot modulus</li><li><code>b</code>: Biot coefficient</li><li><code>ρb</code>: Bulk density</li><li><code>ρf</code>: Fluid density</li><li><code>kp</code>: Permeability</li><li><code>E</code>: Young modulus</li><li><code>ν</code>: Poisson ratio</li><li><code>μ</code>: Fluid viscosity</li><li><code>Pi</code>: Initial pressure</li><li><code>Bf</code>: formation volume, <span>$B_f=\frac{\rho_{f,0}}{\rho_f}$</span></li><li><code>g</code>: Gravity acceleration</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.Mesh" href="#AdFem.Mesh"><code>AdFem.Mesh</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Mesh</code> holds data structures for an unstructured mesh. </p><ul><li><code>nodes</code>: a <span>$n_v \times 2$</span> coordinates array</li><li><code>edges</code>: a <span>$n_{\text{edge}} \times 2$</span> integer array for edges </li><li><code>elems</code>: a <span>$n_e \times 3$</span> connectivity matrix, 1-based. </li><li><code>nnode</code>, <code>nedge</code>, <code>nelem</code>: number of nodes, edges, and elements </li><li><code>ndof</code>: total number of degrees of freedoms </li><li><code>conn</code>: connectivity matrix, <code>nelems × 3</code> or <code>nelems × 6</code>, depending on whether a linear element or a quadratic element is used. </li><li><code>lorder</code>: order of quadrature rule for line integrals (default = 6, 4 gauss points per line segment)</li><li><code>elem_type</code>: type of the element (P1, P2 or BDM1)</li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight">Mesh(m::Int64, n::Int64, h::Float64; order::Int64 = -1, 
            degree::Union{FiniteElementType, Int64} = 1, lorder::Int64 = -1, 
            version::Int64 = 1)</code></pre><p>Constructs a mesh of a rectangular domain. The rectangle is split into <span>$m\times n$</span> cells, and each cell is further split into two triangles.  <code>order</code> specifies the quadrature rule order. <code>degree</code> determines the degree for finite element basis functions.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>AdFem provides three types of triangulations for a rectangular domain. The different types of meshes can be used to validate numerical schemes. For example, we can change to different meshes to verify that bugs of our program do not originate from mesh types. </p><p><img src="https://github.com/ADCMEMarket/ADCMEImages/blob/master/AdFem/mesh_types.png?raw=true" alt/></p></div></div><p><strong>Integration Order : <code>order</code> and <code>lorder</code></strong></p><p>TODO</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MFEM.jl#L13-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.CrackMesh" href="#AdFem.CrackMesh"><code>AdFem.CrackMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CrackMesh(m::Int64, n::Int64, h::Float64, k::Int64 = 1)</code></pre><p>Creates a crack mesh. </p><pre><code class="language-julia">mmesh = CrackMesh(20, 10, 0.1, 4)
visualize_mesh(mmesh)</code></pre><p><img src="https://github.com/ADCMEMarket/ADCMEImages/blob/master/AdFem/crackmesh.PNG?raw=true" alt/></p><p>To access the underlying <a href="#AdFem.Mesh"><code>Mesh</code></a> object, use <code>mmesh.mesh</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MGeom.jl#L2-L15">source</a></section></article><h2 id="Matrix-Assembling-Functions"><a class="docs-heading-anchor" href="#Matrix-Assembling-Functions">Matrix Assembling Functions</a><a id="Matrix-Assembling-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-Assembling-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_fem_stiffness_matrix" href="#AdFem.compute_fem_stiffness_matrix"><code>AdFem.compute_fem_stiffness_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_stiffness_matrix(K::Array{Float64,2}, m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the term </p><p class="math-container">\[\int_{A}\delta \varepsilon :\sigma\mathrm{d}x = \int_A u_AB^TKB\delta u_A\mathrm{d}x\]</p><p>where the constitutive relation is given by </p><p class="math-container">\[\begin{bmatrix}\sigma_{xx}\\\sigma_{yy}\\\sigma_{xy}\end{bmatrix} = K \begin{bmatrix}\varepsilon_{xx}\\\varepsilon_{yy}\\2\varepsilon_{xy}\end{bmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L41-L52">source</a></section><section><div><pre><code class="nohighlight">compute_fem_stiffness_matrix(hmat::PyObject,m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable kernel. <code>hmat</code> has one of the following sizes </p><ul><li><p class="math-container">\[3\times 3\]</p></li><li><p class="math-container">\[4mn \times 3 \times 3\]</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/InvCore.jl#L78-L84">source</a></section><section><div><pre><code class="nohighlight">compute_fem_stiffness_matrix(kappa::PyObject, mesh::Mesh)
compute_fem_stiffness_matrix(kappa::Array{Float64, 3}, mesh::Mesh)
compute_fem_stiffness_matrix(kappa::Array{Float64, 2}, mesh::Mesh)</code></pre><p>Computes the stiffness matrix. Here, the acceptable sizes of <span>$\kappa$</span> </p><ul><li>a <span>$3\times 3$</span> matrix, which is the pointwise uniform stiffness matrix </li><li>a <span>$N_g \times 3 \times 3$</span> tensor, which includes a specific stiffness matrix at each Gauss node</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L266-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_interaction_matrix" href="#AdFem.compute_interaction_matrix"><code>AdFem.compute_interaction_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_interaction_matrix(m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the interaction term </p><p class="math-container">\[\int_A p \delta \varepsilon_v\mathrm{d}x = \int_A p [1,1,0]B^T\delta u_A\mathrm{d}x\]</p><p>Here <span>$\varepsilon_v = \text{tr}\; \varepsilon = \text{div}\; \mathbf{u}$</span>.</p><p>The output is a <span>$mn \times 2(m+1)(n+1)$</span> matrix. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L284-L294">source</a></section><section><div><pre><code class="nohighlight">compute_interaction_matrix(mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L222-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_fvm_tpfa_matrix" href="#AdFem.compute_fvm_tpfa_matrix"><code>AdFem.compute_fvm_tpfa_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fvm_tpfa_matrix(m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the term with two-point flux approximation </p><p class="math-container">\[\int_{A_i} \Delta p \mathrm{d}x = \sum_{j=1}^{n_{\mathrm{faces}}} (p_j-p_i)\]</p><p><img src="https://raw.githubusercontent.com/ADCMEMarket/ADCMEImages/master/AdFem/tpfa.png" alt/></p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>No flow boundary condition is assumed. </p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L415-L426">source</a></section><section><div><pre><code class="nohighlight">compute_fvm_tpfa_matrix(K::Array{Float64}, m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the term with two-point flux approximation with distinct permeability at each cell</p><p class="math-container">\[\int_{A_i} K_i \Delta p \mathrm{d}x = K_i\sum_{j=1}^{n_{\mathrm{faces}}} (p_j-p_i)\]</p><p>Note that <span>$K$</span> is a length <span>$mn$</span> vector, representing values per cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L450-L459">source</a></section><section><div><pre><code class="nohighlight">compute_fvm_tpfa_matrix(K::Array{Float64}, bc::Array{Int64,2}, pval::Array{Float64,1}, m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the term with two-point flux approximation with distinct permeability at each cell</p><p class="math-container">\[\int_{A_i} K_i \Delta p \mathrm{d}x = K_i\sum_{j=1}^{n_{\mathrm{faces}}} (p_j-p_i)\]</p><p>Here <span>$K$</span> is a length <span>$mn$</span> vector, representing values per cell.</p><p>Additionally, Dirichlet boundary conditions are imposed on the boundary edges <code>bc</code> (a <span>$N\times 2$</span> integer matrix),  i.e., the <span>$i$</span>-th edge has value <code>pval</code>. The ghost node method is used for imposing the Dirichlet boundary condition.  The other boundaries are no-blow boundaries, i.e., <span>$\frac{\partial T}{\partial n} = 0$</span>.  The function outputs a length <span>$mn$</span> vector and <span>$mn\times mn$</span> matrix <span>$M$</span>. </p><p class="math-container">\[\int_{A_i} K_i \Delta p \mathrm{d}x = f_i + M_{i,:}\mathbf{p}\]</p><p>Returns both the sparse matrix <code>A</code> and the right hand side <code>rhs</code>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p><code>K</code> can also be missing, in which case <code>K</code> is treated as a all-one vector. </p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L482-L504">source</a></section><section><div><pre><code class="nohighlight">compute_fvm_tpfa_matrix(K::PyObject, bc::Array{Int64,2}, pval::Union{Array{Float64},PyObject}, m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable kernel for <a href="#AdFem.compute_fvm_tpfa_matrix"><code>compute_fvm_tpfa_matrix</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/InvCore.jl#L214-L218">source</a></section><section><div><pre><code class="nohighlight">compute_fvm_tpfa_matrix(K::PyObject, m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable kernel for <a href="#AdFem.compute_fvm_tpfa_matrix"><code>compute_fvm_tpfa_matrix</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/InvCore.jl#L236-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_fem_mass_matrix" href="#AdFem.compute_fem_mass_matrix"><code>AdFem.compute_fem_mass_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_mass_matrix(m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the finite element mass matrix </p><p class="math-container">\[\int_{\Omega} u \delta u \mathrm{d}x\]</p><p>The matrix size is <span>$2(m+1)(n+1) \times 2(m+1)(n+1)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L923-L933">source</a></section><section><div><pre><code class="nohighlight">compute_fem_mass_matrix(ρ::PyObject,m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable kernel. <span>$\rho$</span> is a vector of length <span>$4mn$</span> or <span>$8mn$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/InvCore.jl#L366-L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_fvm_mass_matrix" href="#AdFem.compute_fvm_mass_matrix"><code>AdFem.compute_fvm_mass_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fvm_mass_matrix(m::Int64, n::Int64, h::Float64)</code></pre><p>Returns the FVM mass matrix </p><p class="math-container">\[\int_{A_i} p_i \mathrm{d}x = h^2 p_i \]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L1091-L1098">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_fem_mass_matrix1" href="#AdFem.compute_fem_mass_matrix1"><code>AdFem.compute_fem_mass_matrix1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_mass_matrix1(ρ::Array{Float64,1}, m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the mass matrix for a scalar value <span>$u$</span></p><p class="math-container">\[\int_A \rho u \delta u \mathrm{d} x\]</p><p>The output is a <span>$(m+1)(n+1)\times (m+1)(n+1)$</span> sparse matrix. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L860-L868">source</a></section><section><div><pre><code class="nohighlight">compute_fem_mass_matrix1(m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the mass matrix for a scalar value <span>$u$</span></p><p class="math-container">\[\int_A u \delta u \mathrm{d} x\]</p><p>The output is a <span>$(m+1)(n+1)\times (m+1)(n+1)$</span> sparse matrix. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L909-L917">source</a></section><section><div><pre><code class="nohighlight">compute_fem_mass_matrix1(ρ::PyObject,m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable kernel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/InvCore.jl#L353-L357">source</a></section><section><div><pre><code class="nohighlight">compute_fem_mass_matrix1(rho::Union{PyObject, Array{Float64, 1}}, mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L167-L169">source</a></section><section><div><pre><code class="nohighlight">compute_fem_mass_matrix1(ρ::Union{PyObject, Array{Float64, 1}}, 
        mmesh::Mesh3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM3/MCore.jl#L111-L114">source</a></section><section><div><pre><code class="nohighlight">compute_fem_mass_matrix1(mmesh::Mesh3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM3/MCore.jl#L123-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_fem_stiffness_matrix1" href="#AdFem.compute_fem_stiffness_matrix1"><code>AdFem.compute_fem_stiffness_matrix1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_stiffness_matrix1(K::Array{Float64,2}, m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the term </p><p class="math-container">\[\int_{A} (K \nabla u) \cdot \nabla \delta u \mathrm{d}x = \int_A u_A B^T K B \delta u_A\mathrm{d}x\]</p><p>Returns a <span>$(m+1)\times (n+1)$</span> matrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L89-L97">source</a></section><section><div><pre><code class="nohighlight">compute_fem_stiffness_matrix1(hmat::PyObject, m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable kernel for computing the stiffness matrix.  Two possible shapes for <code>hmat</code> are supported: </p><ul><li><p class="math-container">\[4mn \times 2\times 2\]</p></li><li><p class="math-container">\[2 \times 2\]</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/InvCore.jl#L58-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_fvm_advection_matrix" href="#AdFem.compute_fvm_advection_matrix"><code>AdFem.compute_fvm_advection_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fvm_advection_matrix(v::Union{PyObject, Array{Float64, 2}},
    bc::Array{Int64, 2},bcval::Union{PyObject, Array{Float64}},m::Int64,n::Int64,h::Float64)</code></pre><p>Computes the advection matrix for use in the implicit scheme </p><p class="math-container">\[\int_A \mathbf{v} \cdot \nabla u dx \]</p><p>Here <code>v</code> is a <span>$2mn$</span> vector, where the first <span>$mn$</span> entries corresponds to the first dimension of   <span>$\mathbf{v}$</span> and the remaining <span>$mn$</span> entries corresponds to the second dimension. </p><p>It returns a matrix <span>$mn\times mn$</span> matrix <span>$K$</span> and an auxilliary term <span>$\mathbf{f}$</span> due to boundary conditions.</p><p class="math-container">\[\int_\Omega \mathbf{v} \cdot \nabla u dx = K \mathbf{u} + \mathbf{f}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/InvCore.jl#L269-L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_fem_laplace_matrix1" href="#AdFem.compute_fem_laplace_matrix1"><code>AdFem.compute_fem_laplace_matrix1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_laplace_matrix1(K::Array{Float64, 1}, m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the coefficient matrix for </p><p class="math-container">\[\int_\Omega K \nabla u \cdot \nabla (\delta u) \; dx \]</p><p>Here <span>$K\in \mathbf{R}^{2\times 2}$</span>, <span>$u$</span> is a scalar variable, and <code>K</code> is a <span>$4mn \times 2 \times 2$</span> matrix. </p><p>Returns a <span>$(m+1)(n+1)\times (m+1)(n+1)$</span> sparse matrix. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L1189-L1200">source</a></section><section><div><pre><code class="nohighlight">compute_fem_laplace_matrix1(K::Array{Float64, 2}, m::Int64, n::Int64, h::Float64)</code></pre><p><code>K</code> is duplicated on each Gauss point. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L1245-L1249">source</a></section><section><div><pre><code class="nohighlight">compute_fem_laplace_matrix1(K::Array{Float64, 1}, m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the coefficient matrix for </p><p class="math-container">\[\int_\Omega K\nabla u \cdot \nabla (\delta u) \; dx \]</p><p>Here <code>K</code> is a vector with length <span>$4mn$</span> (defined on Gauss points). </p><p>Returns a <span>$(m+1)(n+1)\times (m+1)(n+1)$</span> sparse matrix. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L1258-L1270">source</a></section><section><div><pre><code class="nohighlight">compute_fem_laplace_matrix1(m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the coefficient matrix for </p><p class="math-container">\[\int_\Omega \nabla u \cdot \nabla (\delta u) \; dx \]</p><p>Returns a <span>$(m+1)(n+1)\times (m+1)(n+1)$</span> sparse matrix. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L1280-L1290">source</a></section><section><div><pre><code class="nohighlight">compute_fem_laplace_matrix1(K::PyObject, m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable kernel. Only <span>$K\in \mathbb{R}^{4mn}$</span> is supported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/InvCore.jl#L439-L443">source</a></section><section><div><pre><code class="nohighlight">compute_fem_laplace_matrix1(kappa::PyObject, mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L97-L99">source</a></section><section><div><pre><code class="nohighlight">compute_fem_laplace_matrix1(kappa::Array{Float64,1}, mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L109-L111">source</a></section><section><div><pre><code class="nohighlight">compute_fem_laplace_matrix1(kappa::PyObject, mesh::Mesh3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM3/MCore.jl#L19-L21">source</a></section><section><div><pre><code class="nohighlight">compute_fem_laplace_matrix1(kappa::Array{Float64,1}, mesh::Mesh3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM3/MCore.jl#L31-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_fem_laplace_matrix" href="#AdFem.compute_fem_laplace_matrix"><code>AdFem.compute_fem_laplace_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_laplace_matrix(m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the coefficient matrix for </p><p class="math-container">\[\int_\Omega \nabla \mathbf{u} \cdot \nabla (\delta \mathbf{u}) \; dx \]</p><p>Here</p><p class="math-container">\[\mathbf{u}  = \begin{bmatrix} u \\ v \end{bmatrix}\]</p><p>and </p><p class="math-container">\[\nabla \mathbf{u} = \begin{bmatrix}u_x &amp; u_y \\ v_x &amp; v_y \end{bmatrix}\]</p><p>Returns a <span>$2(m+1)(n+1)\times 2(m+1)(n+1)$</span> sparse matrix. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L1300-L1318">source</a></section><section><div><pre><code class="nohighlight">compute_fem_laplace_matrix(K::Array{Float64, 1}, m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the coefficient matrix for </p><p class="math-container">\[\int_\Omega K \nabla \mathbf{u} \cdot \nabla (\delta \mathbf{u}) \; dx \]</p><p>Here <span>$K$</span> is a scalar defined on Gauss points. <code>K</code> is a vector of length <span>$4mn$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L1325-L1335">source</a></section><section><div><pre><code class="nohighlight">compute_fem_laplace_matrix(kappa::Union{PyObject, Array{Float64, 1}}, mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L122-L124">source</a></section><section><div><pre><code class="nohighlight">compute_fem_laplace_matrix(kappa::Union{PyObject, Array{Float64, 1}}, mesh::Mesh3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM3/MCore.jl#L44-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_fem_advection_matrix1" href="#AdFem.compute_fem_advection_matrix1"><code>AdFem.compute_fem_advection_matrix1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_advection_matrix1(u0::PyObject,v0::PyObject,m::Int64,n::Int64,h::Float64)</code></pre><p>Computes the advection term for a scalar function <span>$u$</span> defined on an FEM grid. The weak form is </p><p class="math-container">\[\int_\Omega (\mathbf{u}_0 \cdot \nabla u)  \delta u \; d\mathbf{x} = \int_\Omega \left(u_0 \frac{\partial u}{\partial x} \delta u + v_0 \frac{\partial u}{\partial y}  \delta u\right)\; d\mathbf{x}\]</p><p>Here <span>$u_0$</span> and <span>$v_0$</span> are both vectors of length <span>$4mn$</span>. </p><p>Returns a sparse matrix of size <span>$(m+1)(n+1)\times (m+1)(n+1)$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/InvCore.jl#L401-L411">source</a></section><section><div><pre><code class="nohighlight">compute_fem_advection_matrix1(u::Union{Array{Float64,1}, PyObject},v::Union{Array{Float64,1}, PyObject}, mesh::Mesh)
compute_fem_advection_matrix1(u::Array{Float64,1}, v::Array{Float64,1}, mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L195-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_fem_bdm_mass_matrix" href="#AdFem.compute_fem_bdm_mass_matrix"><code>AdFem.compute_fem_bdm_mass_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_bdm_mass_matrix(alpha::Union{Array{Float64,1}, PyObject},beta::Union{Array{Float64,1}, PyObject}, mmesh::Mesh)</code></pre><p>Computes </p><p class="math-container">\[\int_\Omega A\sigma : \delta \tau dx\]</p><p>Here </p><p class="math-container">\[A\sigma = \alpha \sigma + \beta \text{tr} \sigma I\]</p><p>Here <span>$\sigma$</span> and <span>$\tau$</span> are both fourth-order tensors. The output is a  <code>4mmesh.nedge × 4mmesh.nedge</code> matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MBDM.jl#L42-L54">source</a></section><section><div><pre><code class="nohighlight">compute_fem_bdm_mass_matrix(mmesh::Mesh)</code></pre><p>Same as <a href="#AdFem.compute_fem_bdm_mass_matrix"><code>compute_fem_bdm_mass_matrix</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MBDM.jl#L63-L67">source</a></section><section><div><pre><code class="nohighlight">compute_fem_bdm_mass_matrix(alpha::Array{Float64,1},beta::Array{Float64,1}, mmesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MBDM.jl#L74-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_fem_bdm_mass_matrix1" href="#AdFem.compute_fem_bdm_mass_matrix1"><code>AdFem.compute_fem_bdm_mass_matrix1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_bdm_mass_matrix1(alpha::Array{Float64,1}, mmesh::Mesh)</code></pre><p>Computes </p><p class="math-container">\[\int_\Omega \alpha\sigma \cdot \delta \tau dx\]</p><p>Here <span>$\alpha$</span> is a scalar, and <span>$\sigma$</span> and <span>$\delta \tau$</span> are second order tensors. </p><p>The returned value is a <code>2mmesh.nedge × 2mmesh.nedge</code> matrix. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MBDM.jl#L90-L100">source</a></section><section><div><pre><code class="nohighlight">compute_fem_bdm_mass_matrix1(mmesh::Mesh)</code></pre><p>Same as <a href="#AdFem.compute_fem_bdm_mass_matrix1"><code>compute_fem_bdm_mass_matrix1</code></a>, except that <span>$\alpha\equiv 1$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MBDM.jl#L112-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_fem_bdm_div_matrix" href="#AdFem.compute_fem_bdm_div_matrix"><code>AdFem.compute_fem_bdm_div_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_bdm_div_matrix(mmesh::Mesh)</code></pre><p>Computes the coefficient matrix for </p><p class="math-container">\[\int_\Omega \text{div} \tau \delta u dx\]</p><p>Here <span>$\tau \in \mathbb{R}^{2\times 2}$</span> is a fourth-order tensor (not necessarily symmetric). <code>mmesh</code>  uses the BDM1 finite element. The output is a <code>2mmesh.nelem × 4mmesh.nedge</code> matrix. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MBDM.jl#L26-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_fem_bdm_div_matrix1" href="#AdFem.compute_fem_bdm_div_matrix1"><code>AdFem.compute_fem_bdm_div_matrix1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_bdm_div_matrix1(mmesh::Mesh)</code></pre><p>Computes the coefficient matrix for </p><p class="math-container">\[\int_\Omega \text{div} \tau \delta u dx\]</p><p>Here <span>$\tau \in \mathbb{R}^{2}$</span> is a second-order tensor (not necessarily symmetric). <code>mmesh</code>  uses the BDM1 finite element. The output is a <code>mmesh.nelem × 2mmesh.nedge</code> matrix. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MBDM.jl#L6-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_fem_bdm_skew_matrix" href="#AdFem.compute_fem_bdm_skew_matrix"><code>AdFem.compute_fem_bdm_skew_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_bdm_skew_matrix(mmesh::Mesh)</code></pre><p>Computes  <span>$\int_\Omega \sigma : v dx$</span> where </p><p class="math-container">\[v = \begin{bmatrix}0 &amp; \rho \\-\rho &amp; 0 \end{bmatrix}\]</p><p>Here <span>$\sigma$</span> is a fourth-order tensor. </p><p>The returned value is a <code>mmesh.nelem × 4mmesh.nedge</code> matrix. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MBDM.jl#L122-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_fem_boundary_mass_matrix1" href="#AdFem.compute_fem_boundary_mass_matrix1"><code>AdFem.compute_fem_boundary_mass_matrix1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_boundary_mass_matrix1(c::Union{Array{Float64}, PyObject}, bdedge::Array{Int64, 2}, mmesh::Mesh)</code></pre><p>Computes the matrix </p><p class="math-container">\[\int_\Gamma cu \delta u ds\]</p><p>The parameters are </p><ul><li><code>bdedge</code>: a <span>$N_e \times 2$</span> integer array, the boundary edge to integrate on</li><li><code>c</code>: given by a vector of length <span>$4N_e$</span>; currently, each edge has 4 quadrature points;</li></ul><p>The output is a <span>$N_v\times N_v$</span> sparse matrix. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L852-L864">source</a></section></article><h2 id="Vector-Assembling-Functions"><a class="docs-heading-anchor" href="#Vector-Assembling-Functions">Vector Assembling Functions</a><a id="Vector-Assembling-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Vector-Assembling-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_fem_source_term" href="#AdFem.compute_fem_source_term"><code>AdFem.compute_fem_source_term</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_source_term(f1::Array{Float64}, f2::Array{Float64},
m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the term </p><p class="math-container">\[\int_\Omega \mathbf{f}\cdot\delta u \mathrm{d}x\]</p><p>Returns a <span>$2(m+1)(n+1)$</span> vector. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L133-L142">source</a></section><section><div><pre><code class="nohighlight">compute_fem_source_term(f1::PyObject, f2::PyObject,
m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable kernel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/InvCore.jl#L315-L320">source</a></section><section><div><pre><code class="nohighlight">compute_fem_source_term(f1::Union{PyObject,Array{Float64,2}}, f2::Union{PyObject,Array{Float64,2}}, mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L84-L86">source</a></section><section><div><pre><code class="nohighlight">compute_fem_source_term(f1::Union{PyObject,Array{Float64,2}}, 
    f2::Union{PyObject,Array{Float64,2}}, mesh::Mesh3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM3/MCore.jl#L86-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_fvm_source_term" href="#AdFem.compute_fvm_source_term"><code>AdFem.compute_fvm_source_term</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fvm_source_term(f::Array{Float64}, m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the source term </p><p class="math-container">\[\int_{A_i} f\mathrm{d}x\]</p><p>Here <span>$f$</span> has length <span>$4mn$</span> or <span>$mn$</span>. In the first case, an average value of four quadrature nodal values of <span>$f$</span> is used per cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L336-L344">source</a></section><section><div><pre><code class="nohighlight">compute_fvm_source_term(f::PyObject, m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable kernel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/InvCore.jl#L386-L390">source</a></section><section><div><pre><code class="nohighlight">compute_fvm_source_term(f::Array{Float64, 1}, mmesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L777-L779">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_fvm_mechanics_term" href="#AdFem.compute_fvm_mechanics_term"><code>AdFem.compute_fvm_mechanics_term</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fvm_mechanics_term(u::Array{Float64}, m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the mechanic interaction term </p><p class="math-container">\[\int_{A_i} \varepsilon_v\mathrm{d}x\]</p><p>Here </p><p class="math-container">\[\varepsilon_v = \mathrm{tr} \varepsilon = \varepsilon_{xx} + \varepsilon_{yy}\]</p><p>Numerically, we have </p><p class="math-container">\[\varepsilon_v = [1 \ 1 \ 0] B^T \delta u_A\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L360-L375">source</a></section><section><div><pre><code class="nohighlight">compute_fvm_mechanics_term(u::PyObject, m::Int64, n::Int64, h::Float64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L405-L407">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_fem_normal_traction_term" href="#AdFem.compute_fem_normal_traction_term"><code>AdFem.compute_fem_normal_traction_term</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_normal_traction_term(t::Array{Float64,1}, bdedge::Array{Int64},
m::Int64, n::Int64, h::Float64)
compute_fem_normal_traction_term(t::Float64, bdedge::Array{Int64},
m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the normal traction term </p><p class="math-container">\[\int_{\Gamma} t(\mathbf{n})\cdot\delta u \mathrm{d}\]</p><p>Here <span>$t(\mathbf{n})\parallel\mathbf{n}$</span> points <strong>outward</strong> to the domain and the magnitude is given by <code>t</code>.  <code>bdedge</code> is a <span>$N\times2$</span> matrix and each row denotes the indices of two endpoints of the boundary edge. </p><p>See <a href="#AdFem.compute_fem_traction_term"><code>compute_fem_traction_term</code></a> for graphical illustration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L630-L644">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_fem_traction_term" href="#AdFem.compute_fem_traction_term"><code>AdFem.compute_fem_traction_term</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_traction_term(t::Array{Float64, 2},
bdedge::Array{Int64,2}, m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the traction term </p><p class="math-container">\[\int_{\Gamma} t(\mathbf{n})\cdot\delta u \mathrm{d}\]</p><p>The number of rows of <code>t</code> is equal to the number of edges in <code>bdedge</code>.  The first component of <code>t</code> describes the <span>$x$</span> direction traction, while the second  component of <code>t</code> describes the <span>$y$</span> direction traction. </p><p>Also see <a href="#AdFem.compute_fem_normal_traction_term"><code>compute_fem_normal_traction_term</code></a>. </p><p><img src="https://raw.githubusercontent.com/ADCMEMarket/ADCMEImages/master/AdFem/traction.png" alt/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L549-L565">source</a></section><section><div><pre><code class="nohighlight">compute_fem_traction_term(t1::PyObject, t2::PyObject, bdedge::Array{Int64, 2}, mmesh::Mesh)</code></pre><p>Computes the boundary integral </p><p class="math-container">\[\int_\Gamma \mathbf{t}(x,y)\cdot \delta \mathbf{u} d\mathbf{x}\]</p><p>Here <span>$\mathbf{t}(x,y)$</span> is the boundary traction term </p><p class="math-container">\[\mathbf{t}(x,y) = \begin{bmatrix} t_1(x,y) \\ t_2(x,y) \end{bmatrix}\]</p><p>and </p><p class="math-container">\[\mathbf{u} = \begin{bmatrix} u_1(x,y) \\ u_2(x,y) \end{bmatrix}\]</p><p class="math-container">\[t_1\]</p><p>and <span>$t_2$</span> are defined on boundary Gauss points. See <a href="#AdFem.eval_f_on_boundary_edge"><code>eval_f_on_boundary_edge</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L618-L634">source</a></section><section><div><pre><code class="nohighlight">compute_fem_traction_term(t::Array{Float64, 2},
bdedge::Array{Int64,2}, mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L641-L644">source</a></section><section><div><pre><code class="nohighlight">compute_fem_traction_term(t1::Array{Float64, 1}, t2::Array{Float64, 1},
bdedge::Array{Int64,2}, mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L652-L655">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_von_mises_stress_term" href="#AdFem.compute_von_mises_stress_term"><code>AdFem.compute_von_mises_stress_term</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_von_mises_stress_term(K::Array{Float64}, u::Array{Float64}, m::Int64, n::Int64, h::Float64)</code></pre><p>Compute the <a href="https://en.wikipedia.org/wiki/Von_Mises_yield_criterion#Multi-axial_(2D_or_3D)_stress">von Mises stress</a> on the Gauss quadrature nodes. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L805-L809">source</a></section><section><div><pre><code class="nohighlight">compute_von_mises_stress_term(Se::Array{Float64,2},  m::Int64, n::Int64, h::Float64)</code></pre><p><code>Se</code> is a <span>$4mn\times3$</span> array that stores the stress data at each Gauss point. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L845-L849">source</a></section><section><div><pre><code class="nohighlight">compute_von_mises_stress_term(K::Array{Float64, 3}, u::Array{Float64, 1}, mesh::Mesh)
compute_von_mises_stress_term(K::Array{Float64, 2}, u::Array{Float64, 1}, mesh::Mesh)</code></pre><p>Computes the von Mises stress term</p><p class="math-container">\[\sigma_v = \sqrt{\sigma_1^2 - \sigma_1 \sigma_2 + \sigma_2^2 + 3\sigma_{12}^2}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L704-L711">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_fem_source_term1" href="#AdFem.compute_fem_source_term1"><code>AdFem.compute_fem_source_term1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_source_term1(f::Array{Float64},
m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the term </p><p class="math-container">\[\int_\Omega f \delta u dx\]</p><p>Returns a <span>$(m+1)\times (n+1)$</span> vector. <code>f</code> is a length <span>$4mn$</span> vector, given by its values on Gauss points. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L176-L185">source</a></section><section><div><pre><code class="nohighlight">compute_fem_source_term1(f::PyObject,
m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable kernel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/InvCore.jl#L301-L306">source</a></section><section><div><pre><code class="nohighlight">compute_fem_source_term1(f::PyObject, mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L62-L64">source</a></section><section><div><pre><code class="nohighlight">compute_fem_source_term1(f::Array{Float64,1}, mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L74-L76">source</a></section><section><div><pre><code class="nohighlight">compute_fem_source_term1(f::PyObject, mesh::Mesh3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM3/MCore.jl#L64-L66">source</a></section><section><div><pre><code class="nohighlight">compute_fem_source_term1(f::Array{Float64,1}, mesh::Mesh3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM3/MCore.jl#L76-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_fem_flux_term1" href="#AdFem.compute_fem_flux_term1"><code>AdFem.compute_fem_flux_term1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_flux_term1(t::Array{Float64},
bdedge::Array{Int64,2}, m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the traction term </p><p class="math-container">\[\int_{\Gamma} q \delta u \mathrm{d}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L609-L617">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_strain_energy_term" href="#AdFem.compute_strain_energy_term"><code>AdFem.compute_strain_energy_term</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_strain_energy_term(S::Array{Float64, 2}, m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the strain energy </p><p class="math-container">\[\int_{A} \sigma : \delta \varepsilon \mathrm{d}x\]</p><p>where <span>$\sigma$</span> is provided by <code>S</code>, a <span>$4mn \times 3$</span> matrix.  The values <span>$\sigma_{11}, \sigma_{22}, \sigma_{12}$</span> are defined on 4 Gauss points per element. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L1104-L1113">source</a></section><section><div><pre><code class="nohighlight">compute_strain_energy_term(S::PyObject,m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable kernel. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/InvCore.jl#L113-L117">source</a></section><section><div><pre><code class="nohighlight">compute_strain_energy_term(Sigma::Array{Float64, 2}, mmesh::Mesh)</code></pre><p>Computes the strain energy term </p><p class="math-container">\[\int_A \sigma : \varepsilon (\delta u) dx\]</p><p>Here <span>$\sigma$</span> is a fourth-order tensor. <code>Sigma</code> is a <code>ngauss × 3</code> matrix, each row represents  <span>$[\sigma_{11}, \sigma_{22}, \sigma_{12}]$</span> at  each Gauss point. </p><p>The output is a length <code>2mmesh.ndof</code> vector. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L792-L803">source</a></section><section><div><pre><code class="nohighlight">compute_strain_energy_term(Sigma::PyObject, mmesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L813-L815">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_strain_energy_term1" href="#AdFem.compute_strain_energy_term1"><code>AdFem.compute_strain_energy_term1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_strain_energy_term1(S::PyObject, m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the strain energy </p><p class="math-container">\[\int_{A} \sigma : \delta \varepsilon \mathrm{d}x\]</p><p>where <span>$\sigma$</span> is provided by <code>S</code>, a <span>$4mn \times 2$</span> matrix.  The values <span>$\sigma_{31}, \sigma_{32}$</span> are defined on 4 Gauss points per element. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L1147-L1156">source</a></section><section><div><pre><code class="nohighlight">compute_strain_energy_term1(sigma::PyObject, m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable  operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/InvCore.jl#L126-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_fem_viscoelasticity_strain_energy_term" href="#AdFem.compute_fem_viscoelasticity_strain_energy_term"><code>AdFem.compute_fem_viscoelasticity_strain_energy_term</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_viscoelasticity_strain_energy_term(ε0, σ0, ε, A, B, m, n, h)</code></pre><p>Given the constitutive relation</p><p class="math-container">\[\sigma^{n+1} = S \sigma^n + H (\varepsilon^{n+1}-\varepsilon^n),\]</p><p>this function computes </p><p class="math-container">\[\int_A {\sigma:\delta \varepsilon}\mathrm{d} x = \underbrace{\int_A { B \varepsilon^{n+1}:\delta \varepsilon}\mathrm{d} x}  + \underbrace{ \int_A { A \sigma^{n+1}:\delta \varepsilon}\mathrm{d} x - \int_A { B \varepsilon^{n+1}:\delta \varepsilon}\mathrm{d} x }_f\]</p><p>and returns <span>$f$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Viscoelasticity.jl#L3-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_fvm_advection_term" href="#AdFem.compute_fvm_advection_term"><code>AdFem.compute_fvm_advection_term</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fvm_advection_term(v::Union{PyObject, Array{Float64, 2}},
u::Union{PyObject, Array{Float64,1}},m::Int64,n::Int64,h::Float64)</code></pre><p>Computes the advection term using upwind schemes</p><p class="math-container">\[\int_A \mathbf{v} \cdot \nabla u dx \]</p><p>Here <span>$\mathbf{v}$</span> is a <span>$mn\times 2$</span> matrix and <span>$u$</span> is a length <span>$mn$</span> vector. Zero boundary conditions are assumed.  <span>$u$</span> is a vector of length <span>$m\times n$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/InvCore.jl#L250-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_interaction_term" href="#AdFem.compute_interaction_term"><code>AdFem.compute_interaction_term</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_interaction_term(p::Array{Float64, 1}, m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the FVM-FEM interaction term </p><p class="math-container">\[ \begin{bmatrix} \int p \frac{\partial \delta u}{\partial x} dx \\  \int p \frac{\partial \delta v}{\partial y}  dy \end{bmatrix} \]</p><p>The input is a vector of length <span>$mn$</span>. The output is a <span>$2(m+1)(n+1)$</span> vector. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L1405-L1415">source</a></section><section><div><pre><code class="nohighlight">compute_interaction_term(p::PyObject, m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable kernel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/InvCore.jl#L452-L456">source</a></section><section><div><pre><code class="nohighlight">compute_interaction_term(p::Union{PyObject,Array{Float64, 1}}, mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L157-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_fem_laplace_term1" href="#AdFem.compute_fem_laplace_term1"><code>AdFem.compute_fem_laplace_term1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_laplace_term1(u::PyObject,κ::PyObject,m::Int64,n::Int64,h::Float64)
compute_fem_laplace_term1(u::PyObject,m::Int64,n::Int64,h::Float64)
compute_fem_laplace_term1(u::Array{Float64},κ::PyObject, m::Int64,n::Int64,h::Float64)
compute_fem_laplace_term1(u::PyObject,κ::Array{Float64}, m::Int64,n::Int64,h::Float64)</code></pre><p>Computes the Laplace term for a scalar function <span>$u$</span></p><p class="math-container">\[\int_\Omega K\nabla u \cdot \nabla (\delta u) \mathrm{d}x\]</p><p>Here <code>κ</code> is a vector of length <span>$4mn$</span>, and <code>u</code> is a vector of length <span>$(m+1)(n+1)$</span>. </p><p>When <code>κ</code> is not provided, the following term is calculated:</p><p class="math-container">\[\int_\Omega \nabla u \cdot \nabla (\delta u) \mathrm{d}x\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/InvCore.jl#L465-L484">source</a></section><section><div><pre><code class="nohighlight">compute_fem_laplace_term1(u::Array{Float64, 1},nu::Array{Float64, 1}, mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L737-L739">source</a></section><section><div><pre><code class="nohighlight">compute_fem_laplace_term1(u::Union{PyObject, Array{Float64, 1}},
                            nu::Union{PyObject, Array{Float64, 1}},
                            mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L749-L753">source</a></section><section><div><pre><code class="nohighlight">compute_fem_laplace_term1(u::Union{PyObject, Array{Float64, 1}},
    nu::Union{PyObject, Array{Float64, 1}},
    mesh::Mesh3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM3/MCore.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_fem_traction_term1" href="#AdFem.compute_fem_traction_term1"><code>AdFem.compute_fem_traction_term1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_traction_term1(t::Array{Float64, 2},
bdedge::Array{Int64,2}, m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the traction term </p><p class="math-container">\[\int_{\Gamma} t(n) \delta u \mathrm{d}\]</p><p>The number of rows of <code>t</code> is equal to the number of edges in <code>bdedge</code>.  The output is a length <span>$(m+1)*(n+1)$</span> vector. </p><p>Also see <a href="#AdFem.compute_fem_traction_term"><code>compute_fem_traction_term</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L582-L595">source</a></section><section><div><pre><code class="nohighlight">compute_fem_traction_term1(t::Array{Float64, 1},
bdedge::Array{Int64,2}, mesh::Mesh)</code></pre><p>Computes the boundary integral </p><p class="math-container">\[\int_{\Gamma} t(x, y) \delta u dx\]</p><p>Returns a vector of size <code>dof</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L503-L512">source</a></section><section><div><pre><code class="nohighlight">compute_fem_traction_term1(t::PyObject,bdedge::Array{Int64, 2}, mmesh::Mesh)</code></pre><p>Computes the boundary integral </p><p class="math-container">\[\int_{\Gamma} t(x, y) \delta u dx\]</p><p>Returns a vector of size <code>dof</code>. </p><p>Here <span>$t$</span> is defined on boundary Gauss points, e.g., the quantity computed from <a href="#AdFem.eval_f_on_boundary_edge"><code>eval_f_on_boundary_edge</code></a>. </p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Currently, only P1 element is supported. </p></div></div><p><strong>Example</strong></p><p>Here is an example to evaluate the boundary integral on a domain <span>$[0,1]^2$</span></p><p class="math-container">\[\int_{0}^1 t(x, 1) \delta u dx\]</p><pre><code class="language-julia">mmesh = Mesh(10,10,0.1)
a = constant(1.0)
f = (x,y)-&gt;x+y*a
top = bcedge((x1,y1,x2,y2)-&gt;(y1&gt;0.99) &amp;&amp; (y2&gt;0.99), mmesh)
t = eval_f_on_boundary_edge(f, top, mmesh; tensor_input = true)
T = compute_fem_traction_term1(t, top, mmesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L576-L605">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_fem_boundary_mass_term1" href="#AdFem.compute_fem_boundary_mass_term1"><code>AdFem.compute_fem_boundary_mass_term1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_fem_boundary_mass_term1(u::Union{Array{Float64}, PyObject}, 
    c::Union{Array{Float64}, PyObject}, bdedge::Array{Int64, 2}, mmesh::Mesh)</code></pre><p>Computes the term </p><p class="math-container">\[\int_\Gamma cu \delta u ds\]</p><p>The parameters are </p><ul><li><code>u</code> : a vector of length <span>$N_v$</span> </li><li><code>bdedge</code> : a <span>$N_e \times 2$</span> integer array, the boundary edge to integrate on</li><li><code>c</code>: given by a vector of length <span>$4N_e$</span>; currently, each edge has 4 quadrature points;</li></ul><p>The output is a <span>$N_v\times N_v$</span> sparse matrix. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L874-L888">source</a></section></article><h2 id="Evaluation-Functions"><a class="docs-heading-anchor" href="#Evaluation-Functions">Evaluation Functions</a><a id="Evaluation-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation-Functions" title="Permalink"></a></h2><h3 id="Elementwise"><a class="docs-heading-anchor" href="#Elementwise">Elementwise</a><a id="Elementwise-1"></a><a class="docs-heading-anchor-permalink" href="#Elementwise" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="AdFem.eval_f_on_gauss_pts" href="#AdFem.eval_f_on_gauss_pts"><code>AdFem.eval_f_on_gauss_pts</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval_f_on_gauss_pts(f::Function, m::Int64, n::Int64, h::Float64; tensor_input::Bool = false)</code></pre><p>Evaluates <code>f</code> at Gaussian points and return the result as <span>$4mn$</span> vector <code>out</code> (4 Gauss points per element)</p><p>If <code>tensor_input = true</code>, the function <code>f</code> is assumed to map a tensor to a tensor output.</p><p><img src="https://raw.githubusercontent.com/ADCMEMarket/ADCMEImages/master/AdFem/gauss.png" alt/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L941-L949">source</a></section><section><div><pre><code class="nohighlight">eval_f_on_gauss_pts(f::Function, mesh::Mesh; tensor_input::Bool = false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L5-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.eval_f_on_dof_pts" href="#AdFem.eval_f_on_dof_pts"><code>AdFem.eval_f_on_dof_pts</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval_f_on_dof_pts(f::Function, mesh::Mesh)</code></pre><p>Evaluates <code>f</code> on the DOF points. </p><ul><li>For P1 element, the DOF points are FEM points and therefore <code>eval_f_on_dof_pts</code> is equivalent to <code>eval_on_on_fem_pts</code>.</li><li>For P2 element, the DOF points are FEM points plus the middle point for each edge. </li></ul><p>Returns a vector of length <code>mesh.ndof</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L39-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.eval_f_on_boundary_node" href="#AdFem.eval_f_on_boundary_node"><code>AdFem.eval_f_on_boundary_node</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval_f_on_boundary_node(f::Function, bdnode::Array{Int64}, m::Int64, n::Int64, h::Float64)</code></pre><p>Returns a vector of the same length as <code>bdnode</code> whose entries corresponding to <code>bdnode</code> nodes are filled with values computed from <code>f</code>.</p><p><code>f</code> has the following signature </p><pre><code class="nohighlight">f(x::Float64, y::Float64)::Float64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L992-L1002">source</a></section><section><div><pre><code class="nohighlight">eval_f_on_boundary_node(f::Function, bdnode::Array{Int64}, mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L685-L687">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.eval_strain_on_gauss_pts" href="#AdFem.eval_strain_on_gauss_pts"><code>AdFem.eval_strain_on_gauss_pts</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval_strain_on_gauss_pts(u::Array{Float64}, m::Int64, n::Int64, h::Float64)</code></pre><p>Computes the strain on Gauss points.  Returns a <span>$4mn\times3$</span> matrix, where each row denotes <span>$(\varepsilon_{11}, \varepsilon_{22}, 2\varepsilon_{12})$</span> at the corresponding Gauss point. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L1035-L1041">source</a></section><section><div><pre><code class="nohighlight">eval_strain_on_gauss_pts(u::PyObject, m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable kernel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/InvCore.jl#L138-L142">source</a></section><section><div><pre><code class="nohighlight">eval_strain_on_gauss_pts(u::Array{Float64}, mmesh::Mesh)</code></pre><p>Evaluates the strain on Gauss points. <code>u</code> is a vector of size <code>2mmesh.ndof</code>.</p><p>The output is a <code>ngauss × 3</code> vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L827-L833">source</a></section><section><div><pre><code class="nohighlight">eval_strain_on_gauss_pts(u::PyObject, mmesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L841-L843">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.eval_strain_on_gauss_pts1" href="#AdFem.eval_strain_on_gauss_pts1"><code>AdFem.eval_strain_on_gauss_pts1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval_strain_on_gauss_pts1(u::PyObject, m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable kernel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/InvCore.jl#L154-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.eval_f_on_fvm_pts" href="#AdFem.eval_f_on_fvm_pts"><code>AdFem.eval_f_on_fvm_pts</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval_f_on_fvm_pts(f::Function, m::Int64, n::Int64, h::Float64; tensor_input::Bool = false)</code></pre><p>Returns <span>$f(x_i, y_i)$</span> where <span>$(x_i,y_i)$</span> are FVM nodes. </p><p>If <code>tensor_input = true</code>, the function <code>f</code> is assumed to map a tensor to a tensor output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L975-L981">source</a></section><section><div><pre><code class="nohighlight">eval_f_on_fvm_pts(f::Function, mesh::Mesh; tensor_input::Bool = false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L28-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.eval_f_on_fem_pts" href="#AdFem.eval_f_on_fem_pts"><code>AdFem.eval_f_on_fem_pts</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval_f_on_fem_pts(f::Function, m::Int64, n::Int64, h::Float64; tensor_input::Bool = false)</code></pre><p>Returns <span>$f(x_i, y_i)$</span> where <span>$(x_i,y_i)$</span> are FEM nodes. </p><p>If <code>tensor_input = true</code>, the function <code>f</code> is assumed to map a tensor to a tensor output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L959-L965">source</a></section><section><div><pre><code class="nohighlight">eval_f_on_fem_pts(f::Function, mesh::Mesh; tensor_input::Bool = false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L17-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.eval_grad_on_gauss_pts1" href="#AdFem.eval_grad_on_gauss_pts1"><code>AdFem.eval_grad_on_gauss_pts1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval_grad_on_gauss_pts1(u::Array{Float64,1}, m::Int64, n::Int64, h::Float64)</code></pre><p>Evaluates <span>$\nabla u$</span> on each Gauss point. Here <span>$u$</span> is a scalar function. </p><p>The input <code>u</code> is a vector of length <span>$(m+1)*(n+1)$</span>. The output is a matrix of size <span>$4mn\times 2$</span>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L1344-L1351">source</a></section><section><div><pre><code class="nohighlight">eval_grad_on_gauss_pts1(u::PyObject, m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable kernel. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/InvCore.jl#L327-L331">source</a></section><section><div><pre><code class="nohighlight">eval_grad_on_gauss_pts1(u::Union{Array{Float64,1}, PyObject}, mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L236-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.eval_grad_on_gauss_pts" href="#AdFem.eval_grad_on_gauss_pts"><code>AdFem.eval_grad_on_gauss_pts</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval_grad_on_gauss_pts(u::Array{Float64,1}, m::Int64, n::Int64, h::Float64)</code></pre><p>Evaluates <span>$\nabla u$</span> on each Gauss point. Here <span>$\mathbf{u} = (u, v)$</span>.</p><p class="math-container">\[\texttt{g[i,:,:]} = \begin{bmatrix} u_x &amp; u_y\\ v_x &amp; v_y \end{bmatrix}\]</p><p>The input <code>u</code> is a vector of length <span>$2(m+1)*(n+1)$</span>. The output is a matrix of size <span>$4mn\times 2 \times 2$</span>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L1384-L1393">source</a></section><section><div><pre><code class="nohighlight">eval_grad_on_gauss_pts(u::PyObject, m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable kernel. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/InvCore.jl#L340-L344">source</a></section></article><h3 id="Edgewise"><a class="docs-heading-anchor" href="#Edgewise">Edgewise</a><a id="Edgewise-1"></a><a class="docs-heading-anchor-permalink" href="#Edgewise" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="AdFem.eval_scalar_on_boundary_edge" href="#AdFem.eval_scalar_on_boundary_edge"><code>AdFem.eval_scalar_on_boundary_edge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval_scalar_on_boundary_edge(u::Union{PyObject, Array{Float64, 1}},
        edge::Array{Int64, 1}, mmesh::Mesh)</code></pre><p>Returns an array of values on the Gauss quadrature nodes for each edge. </p><ul><li><code>u</code>: nodal values </li><li><code>edge</code>: a <span>$N\times 2$</span> integer array; each row represents an edge <span>$(x_1, x_2)$</span></li></ul><p>The returned array consists of <span>$(y_1, y_2, \ldots)$</span></p><p><img src="https://github.com/ADCMEMarket/ADCMEImages/blob/master/AdFem/docs/eval_scalar_on_boundary_edge.png?raw=true" alt/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L896-L908">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.eval_f_on_boundary_edge" href="#AdFem.eval_f_on_boundary_edge"><code>AdFem.eval_f_on_boundary_edge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval_f_on_boundary_edge(f::Function, bdedge::Array{Int64,2}, m::Int64, n::Int64, h::Float64)</code></pre><p>Returns a vector of the same length as <code>bdedge</code> whose entries corresponding to <code>bdedge</code> nodes are filled with values computed from <code>f</code>.</p><p><code>f</code> has the following signature </p><pre><code class="nohighlight">f(x::Float64, y::Float64)::Float64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L1012-L1022">source</a></section><section><div><pre><code class="nohighlight">eval_f_on_boundary_edge(f::Function, bdedge::Array{Int64, 2}, mesh::Mesh; tensor_input::Bool = false)</code></pre><p>Evaluates <code>f</code> on the boundary <strong>Gauss points</strong>. Here <code>f</code> has the signature</p><p><code>f(Float64, Float64)::Float64</code></p><p>or </p><p><code>f(PyObject, PyObject)::PyObject</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L663-L673">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.eval_strain_on_boundary_edge" href="#AdFem.eval_strain_on_boundary_edge"><code>AdFem.eval_strain_on_boundary_edge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval_strain_on_boundary_edge(u::Union{PyObject, Array{Float64, 1}},
edge::Array{Int64, 2}, mmesh::Mesh)</code></pre><p>Returns an array of strain tensors on the Gauss quadrature nodes for each edge. </p><p>The returned value has size <span>$N_e N_g\times 3$</span>. Here <span>$N_e$</span> is the number of edges, and <span>$N_g$</span> is the number of  Gauss points on the edge. Each row of <code>edge</code>, <span>$(l,r)$</span>, has the following property: <span>$l &lt; r$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L918-L926">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.eval_normal_and_shear_stress_on_boundary_edge" href="#AdFem.eval_normal_and_shear_stress_on_boundary_edge"><code>AdFem.eval_normal_and_shear_stress_on_boundary_edge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval_normal_and_shear_stress_on_boundary_edge(sigma::Union{PyObject, Array{Float64, 2}},
    edge::Array{Int64, 2}, mmesh::Mesh)</code></pre><p>Calculates the normal and shear stress on boundary edges. </p><p class="math-container">\[\sigma_n = (\sigma n)\cdot n, \tau = (\sigma n) \cdot m\]</p><p>Here  <span>$m = \begin{bmatrix}n_2\\-n_1\end{bmatrix}$</span></p><p><img src="https://github.com/ADCMEMarket/ADCMEImages/blob/master/AdFem/docs/shear_normal.png?raw=true" alt/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L938-L951">source</a></section></article><h2 id="Boundary-Conditions"><a class="docs-heading-anchor" href="#Boundary-Conditions">Boundary Conditions</a><a id="Boundary-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-Conditions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="AdFem.fem_impose_Dirichlet_boundary_condition" href="#AdFem.fem_impose_Dirichlet_boundary_condition"><code>AdFem.fem_impose_Dirichlet_boundary_condition</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fem_impose_Dirichlet_boundary_condition(A::SparseMatrixCSC{Float64,Int64}, 
bd::Array{Int64}, m::Int64, n::Int64, h::Float64)</code></pre><p>Imposes the Dirichlet boundary conditions on the matrix <code>A</code>.</p><p>Returns 2 matrix, </p><p class="math-container">\[\begin{bmatrix}
A_{BB} &amp; A_{BI} \\ 
A_{IB} &amp; A_{II} 
\end{bmatrix} \Rightarrow \begin{bmatrix}
I &amp; 0 \\ 
0 &amp; A_{II} 
\end{bmatrix}, \quad \begin{bmatrix}
0 \\ 
A_{IB} 
\end{bmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L208-L227">source</a></section><section><div><pre><code class="nohighlight">fem_impose_Dirichlet_boundary_condition(L::SparseTensor, bdnode::Array{Int64}, m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable kernel for imposing the Dirichlet boundary of a vector-valued function. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/InvCore.jl#L42-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.fem_impose_Dirichlet_boundary_condition1" href="#AdFem.fem_impose_Dirichlet_boundary_condition1"><code>AdFem.fem_impose_Dirichlet_boundary_condition1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fem_impose_Dirichlet_boundary_condition1(A::SparseMatrixCSC{Float64,Int64}, 
    bd::Array{Int64}, m::Int64, n::Int64, h::Float64)</code></pre><p>Imposes the Dirichlet boundary conditions on the matrix <code>A</code> Returns 2 matrix, </p><p class="math-container">\[\begin{bmatrix}
A_{BB} &amp; A_{BI} \\ 
A_{IB} &amp; A_{II} 
\end{bmatrix} \Rightarrow \begin{bmatrix}
I &amp; 0 \\ 
0 &amp; A_{II} 
\end{bmatrix}, \quad \begin{bmatrix}
0 \\ 
A_{IB} 
\end{bmatrix}\]</p><p><code>bd</code> must NOT have duplicates. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L251-L271">source</a></section><section><div><pre><code class="nohighlight">fem_impose_Dirichlet_boundary_condition1(L::SparseTensor, bdnode::Array{Int64}, m::Int64, n::Int64, h::Float64)</code></pre><p>A differentiable kernel for imposing the Dirichlet boundary of a scalar-valued function. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/InvCore.jl#L26-L30">source</a></section><section><div><pre><code class="nohighlight">fem_impose_Dirichlet_boundary_condition1(L::SparseTensor, bdnode::Array{Int64}, mesh::Mesh)</code></pre><p>A differentiable kernel for imposing the Dirichlet boundary of a scalar-valued function. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L141-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.impose_Dirichlet_boundary_conditions" href="#AdFem.impose_Dirichlet_boundary_conditions"><code>AdFem.impose_Dirichlet_boundary_conditions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">impose_Dirichlet_boundary_conditions(A::Union{SparseArrays, Array{Float64, 2}}, rhs::Array{Float64,1}, bdnode::Array{Int64, 1}, 
    bdval::Array{Float64,1})
impose_Dirichlet_boundary_conditions(A::SparseTensor, rhs::Union{Array{Float64,1}, PyObject}, bdnode::Array{Int64, 1}, 
    bdval::Union{Array{Float64,1}, PyObject})</code></pre><p>Algebraically impose the Dirichlet boundary conditions. We want the solutions at indices <code>bdnode</code> to be <code>bdval</code>. Given the matrix and the right hand side</p><p class="math-container">\[\begin{bmatrix} A_{II} &amp; A_{IB} \\ A_{BI} &amp; A_{BB} \end{bmatrix}, \begin{bmatrix}r_I \\ r_B \end{bmatrix}\]</p><p>The function returns</p><p class="math-container">\[\begin{bmatrix} A_{II} &amp; 0 \\ 0 &amp; I \end{bmatrix}, \begin{bmatrix}r_I - A_{IB} u_B \\ r_B \end{bmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MUtils.jl#L170-L183">source</a></section><section><div><pre><code class="nohighlight">impose_Dirichlet_boundary_conditions(A::SparseTensor, bdnode::Array{Int64, 1})</code></pre><p>A helper function to impose homogeneous Dirichlet boundary condition. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MUtils.jl#L215-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.impose_bdm_traction_boundary_condition1" href="#AdFem.impose_bdm_traction_boundary_condition1"><code>AdFem.impose_bdm_traction_boundary_condition1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">impose_bdm_traction_boundary_condition1(gN::Array{Float64, 1}, bdedge::Array{Int64, 2}, mesh::Mesh)</code></pre><p>Imposes the BDM traction boundary condition </p><p class="math-container">\[\int_{\Gamma} \sigma \mathbf{n} g_N ds\]</p><p>Here <span>$\sigma$</span> is a second-order tensor. <code>gN</code> is defined on the Gauss points, e.g. </p><pre><code class="language-julia">gN = eval_f_on_boundary_edge(func, bdedge, mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MBDM.jl#L147-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.impose_bdm_traction_boundary_condition" href="#AdFem.impose_bdm_traction_boundary_condition"><code>AdFem.impose_bdm_traction_boundary_condition</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">impose_bdm_traction_boundary_condition(g1:Array{Float64, 1}, g2:Array{Float64, 1},
bdedge::Array{Int64, 2}, mesh::Mesh)</code></pre><p>Imposes the BDM traction boundary condition </p><p class="math-container">\[\int_{\Gamma} \sigma \mathbf{n} \cdot \mathbf{g}_N ds\]</p><p>Here <span>$\sigma$</span> is a fourth-order tensor. <span>$\mathbf{g}_N = \begin{bmatrix}g_{N1}\\ g_{N2}\end{bmatrix}$</span> See <a href="#AdFem.impose_bdm_traction_boundary_condition1"><code>impose_bdm_traction_boundary_condition1</code></a>.</p><p>Returns a <code>dof</code> vector and a <code>val</code> vector. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MBDM.jl#L197-L209">source</a></section></article><h2 id="Visualization"><a class="docs-heading-anchor" href="#Visualization">Visualization</a><a id="Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization" title="Permalink"></a></h2><p>In <code>visualize_scalar_on_XXX_points</code>, the first argument is the data matrix. When the data matrix is 1D, one snapshot is plotted. When the data matrix is 2D, it is understood as multiple snapshots at different time steps (each row is a snapshot). When the data matrix is 3D, it is understood as <code>time step × height × width</code>. </p><article class="docstring"><header><a class="docstring-binding" id="AdFem.visualize_mesh" href="#AdFem.visualize_mesh"><code>AdFem.visualize_mesh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">visualize_mesh(mesh::Mesh)</code></pre><p>Visualizes the unstructured meshes. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MVisualize.jl#L3-L7">source</a></section><section><div><pre><code class="nohighlight">visualize_mesh(mmesh::Mesh3; filename::Union{Missing, String} = missing)</code></pre><p>Visualizes the unstructured mesh <code>mmesh</code>. When <code>filename</code> is provided, a screenshot is saved to <code>filename</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM3/MVisualize.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.visualize_pressure" href="#AdFem.visualize_pressure"><code>AdFem.visualize_pressure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">visualize_pressure(U::Array{Float64, 2}, m::Int64, n::Int64, h::Float64)</code></pre><p>Visualizes pressure. <code>U</code> is the solution vector. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Visualization.jl#L7-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.visualize_displacement" href="#AdFem.visualize_displacement"><code>AdFem.visualize_displacement</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">visualize_displacement(u::Array{Float64, 2}, m::Int64, n::Int64, h::Float64)</code></pre><p>Generates scattered plot animation for displacement <span>$u\in \mathbb{R}^{(NT+1)\times 2(m+1)(n+1)}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Visualization.jl#L333-L337">source</a></section><section><div><pre><code class="nohighlight">visualize_displacement(u::Array{Float64, 1}, mmesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MVisualize.jl#L116-L118">source</a></section><section><div><pre><code class="nohighlight">visualize_displacement(u::Array{Float64, 2}, mmesh::Mesh)</code></pre><p>Generates scattered plot animation for displacement <span>$u\in \mathbb{R}^{(NT+1)\times 2N_{\text{dof}}}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MVisualize.jl#L149-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.visualize_stress" href="#AdFem.visualize_stress"><code>AdFem.visualize_stress</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">visualize_stress(K::Array{Float64, 2}, U::Array{Float64, 2}, m::Int64, n::Int64, h::Float64; name::String=&quot;&quot;)</code></pre><p>Visualizes displacement. <code>U</code> is the solution vector, <code>K</code> is the elasticity matrix (<span>$3\times 3$</span>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Visualization.jl#L65-L70">source</a></section><section><div><pre><code class="nohighlight">visualize_stress(Se::Array{Float64, 2}, m::Int64, n::Int64, h::Float64; name::String=&quot;&quot;)</code></pre><p>Visualizes the Von Mises stress. <code>Se</code> is the Von Mises at the cell center. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Visualization.jl#L126-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.visualize_von_mises_stress" href="#AdFem.visualize_von_mises_stress"><code>AdFem.visualize_von_mises_stress</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">visualize_von_mises_stress(Se::Array{Float64, 2}, m::Int64, n::Int64, h::Float64; name::String=&quot;&quot;)</code></pre><p>Visualizes the Von Mises stress. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Visualization.jl#L186-L190">source</a></section><section><div><pre><code class="nohighlight">visualize_von_mises_stress(K::Array{Float64}, u::Array{Float64, 1}, mmesh::Mesh, args...; kwargs...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MVisualize.jl#L126-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.visualize_scalar_on_gauss_points" href="#AdFem.visualize_scalar_on_gauss_points"><code>AdFem.visualize_scalar_on_gauss_points</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">visualize_scalar_on_gauss_points(u::Array{Float64,1}, m::Int64, n::Int64, h::Float64, args...;kwargs...)</code></pre><p>Visualizes the scalar <code>u</code> using pcolormesh. Here <code>u</code> is a length <span>$4mn$</span> vector and the values are defined on the Gauss points</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Visualization.jl#L415-L419">source</a></section><section><div><pre><code class="nohighlight">visualize_scalar_on_gauss_points(u::Array{Float64,1}, mesh::Mesh, args...;kwargs...)</code></pre><p>Visualizes scalar values on Gauss points. For unstructured meshes, the values on each element are averaged to produce a uniform value for each element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MVisualize.jl#L76-L80">source</a></section><section><div><pre><code class="nohighlight">visualize_scalar_on_fvm_points(u::Array{Float64,1}, mmesh::Mesh3; filename::Union{Missing, String} = missing)</code></pre><p>Visualizes the unstructured mesh <code>mmesh</code> with elements colored with values <code>u</code>. When <code>filename</code> is provided, a screenshot is saved to <code>filename</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM3/MVisualize.jl#L49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.visualize_scalar_on_fem_points" href="#AdFem.visualize_scalar_on_fem_points"><code>AdFem.visualize_scalar_on_fem_points</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">visualize_scalar_on_fem_points(u::Array{Float64,1}, m::Int64, n::Int64, h::Float64, args...;kwargs...)</code></pre><p>Visualizes the scalar <code>u</code> using pcolormesh. Here <code>u</code> is a length <span>$(m+1)(n+1)$</span> vector and the values are defined on the FEM points</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Visualization.jl#L519-L523">source</a></section><section><div><pre><code class="nohighlight">visualize_scalar_on_fem_points(u::Array{Float64,2}, m::Int64, n::Int64, h::Float64, args...;kwargs...)</code></pre><p>Visualizes the scalar <code>u</code> using pcolormesh. Here <code>u</code> is a matrix of size <span>$NT \times (m+1)(n+1)$</span> (<span>$NT$</span> is the number of time steps) and the values are defined on the FEM points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Visualization.jl#L543-L547">source</a></section><section><div><pre><code class="nohighlight">visualize_scalar_on_fem_points(u::Array{Float64,1}, mesh::Mesh, args...;
    with_mesh::Bool = false, kwargs...)</code></pre><p>Visualizes the nodal values <code>u</code> on the unstructured mesh <code>mesh</code>.</p><ul><li><code>with_mesh</code>: if true, the unstructured mesh is also plotted. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MVisualize.jl#L24-L31">source</a></section><section><div><pre><code class="nohighlight">visualize_scalar_on_fem_points(U::Array{Float64,2}, mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MVisualize.jl#L190-L192">source</a></section><section><div><pre><code class="nohighlight">visualize_scalar_on_fem_points(u::Array{Float64,1}, mmesh::Mesh3; filename::Union{Missing, String} = missing)</code></pre><p>Visualizes the unstructured mesh <code>mmesh</code> with nodes colored with values <code>u</code>. When <code>filename</code> is provided, a screenshot is saved to <code>filename</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM3/MVisualize.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.visualize_scalar_on_fvm_points" href="#AdFem.visualize_scalar_on_fvm_points"><code>AdFem.visualize_scalar_on_fvm_points</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">visualize_scalar_on_fvm_points(φ::Array{Float64, 3}, m::Int64, n::Int64, h::Float64;
vmin::Union{Real, Missing} = missing, vmax::Union{Real, Missing} = missing)</code></pre><p>Generates scattered potential animation for the potential <span>$\phi\in \mathbb{R}^{(NT+1)\times n \times m}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Visualization.jl#L261-L266">source</a></section><section><div><pre><code class="nohighlight">visualize_scalar_on_fvm_points(u::Array{Float64,1}, mesh::Mesh, args...;kwargs...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MVisualize.jl#L92-L94">source</a></section><section><div><pre><code class="nohighlight">visualize_scalar_on_fvm_points(u::Array{Float64,1}, mmesh::Mesh3; filename::Union{Missing, String} = missing)</code></pre><p>Visualizes the unstructured mesh <code>mmesh</code> with elements colored with values <code>u</code>. When <code>filename</code> is provided, a screenshot is saved to <code>filename</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM3/MVisualize.jl#L37-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.visualize_vector_on_fem_points" href="#AdFem.visualize_vector_on_fem_points"><code>AdFem.visualize_vector_on_fem_points</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">visualize_vector_on_fem_points(u1::Array{Float64,1}, u2::Array{Float64,1}, mesh::Mesh, args...;kwargs...)</code></pre><p>Visualizes a vector on the mesh <code>mesh</code>. Here <code>u1</code> and <code>u2</code> are the <span>$x$</span> and <span>$y$</span> component of the vector. They are defined on the FEM nodes (not DOFs). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MVisualize.jl#L134-L138">source</a></section></article><h2 id="Modeling-Tools"><a class="docs-heading-anchor" href="#Modeling-Tools">Modeling Tools</a><a id="Modeling-Tools-1"></a><a class="docs-heading-anchor-permalink" href="#Modeling-Tools" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="AdFem.layer_model" href="#AdFem.layer_model"><code>AdFem.layer_model</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">layer_model(u::Array{Float64, 1}, m::Int64, n::Int64, h::Float64)</code></pre><p>Convert the vertical profile of a quantity to a layer model.  The input <code>u</code> is a length <span>$n$</span> vector, the output is a length <span>$4mn$</span> vector, representing the <span>$4mn$</span> Gauss points. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Utils.jl#L47-L52">source</a></section><section><div><pre><code class="nohighlight">layer_model(u::PyObject, m::Int64, n::Int64, h::Float64)</code></pre><p>A differential kernel for <a href="#AdFem.layer_model"><code>layer_model</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Utils.jl#L58-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_vel" href="#AdFem.compute_vel"><code>AdFem.compute_vel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_vel(a::Union{PyObject, Array{Float64, 1}},
v0::Union{PyObject, Float64},psi::Union{PyObject, Array{Float64, 1}},
sigma::Union{PyObject, Array{Float64, 1}},
tau::Union{PyObject, Array{Float64, 1}},eta::Union{PyObject, Float64})</code></pre><p>Computes <span>$x = u_3(x_1, x_2)$</span> from rate and state friction. The governing equation is </p><p class="math-container">\[a \sinh^{-1}\left( \frac{x - u}{\Delta t} \frac{1}{2V_0} e^{\frac{\Psi}{a}} \right) \sigma - \tau + \eta \frac{x-u}{\Delta t} = 0\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/InvCore.jl#L169-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_plane_strain_matrix" href="#AdFem.compute_plane_strain_matrix"><code>AdFem.compute_plane_strain_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_plane_strain_matrix(E::Float64, ν::Float64)</code></pre><p>Computes the stiffness matrix for 2D plane strain. The matrix is given by </p><p class="math-container">\[\frac{E(1-\nu)}{(1+\nu)(1-2\nu)}\begin{bmatrix}
1 &amp; \frac{\nu}{1-\nu} &amp; \frac{\nu}{1-\nu}\\ 
\frac{\nu}{1-\nu} &amp; 1 &amp; \frac{\nu}{1-\nu} \\ 
\frac{\nu}{1-\nu} &amp; \frac{\nu}{1-\nu} &amp; 1
\end{bmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L731-L741">source</a></section><section><div><pre><code class="nohighlight">compute_plane_strain_matrix(E::Union{PyObject, Array{Float64, 1}}, nu::Union{PyObject, Array{Float64, 1}})</code></pre><p>Returns the pointwise plane strain matrix of size <span>$N\times 3 \times 3$</span>. Here <span>$N$</span> is the length of <span>$E$</span> or <span>$\nu$</span>.  <span>$N$</span> can be any number. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L771-L776">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_plane_stress_matrix" href="#AdFem.compute_plane_stress_matrix"><code>AdFem.compute_plane_stress_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_plane_stress_matrix(E::Float64, ν::Float64)</code></pre><p>Computes the stiffness matrix for 2D plane stress. The matrix is given by </p><p class="math-container">\[\frac{E}{(1+\nu)(1-2\nu)}\begin{bmatrix}
1-\nu &amp; \nu &amp; 0\\ 
\nu &amp; 1 &amp; 0 \\ 
0 &amp; 0 &amp; \frac{1-2\nu}{2}
\end{bmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L751-L761">source</a></section><section><div><pre><code class="nohighlight">compute_plane_stress_matrix(E::Union{PyObject, Array{Float64, 1}}, nu::Union{PyObject, Array{Float64, 1}})</code></pre><p>Returns the pointwise plane stress matrix of size <span>$N\times 3 \times 3$</span>. Here <span>$N$</span> is the length of <span>$E$</span> or <span>$\nu$</span>.  <span>$N$</span> can be any number. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L787-L792">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_space_varying_tangent_elasticity_matrix" href="#AdFem.compute_space_varying_tangent_elasticity_matrix"><code>AdFem.compute_space_varying_tangent_elasticity_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_space_varying_tangent_elasticity_matrix(mu::Union{PyObject, Array{Float64,1}},m::Int64,n::Int64,h::Float64,type::Int64=1)</code></pre><p>Computes the space varying tangent elasticity matrix given <span>$\mu$</span>. It returns a matrix of size <span>$4mn\times 2\times 2$</span></p><ul><li>If <code>type==1</code>, the <span>$i$</span>-th matrix will be </li></ul><p class="math-container">\[\begin{bmatrix}\mu_i &amp; 0 \\ 0 &amp; \mu_i \end{bmatrix}\]</p><ul><li>If <code>type==2</code>, the <span>$i$</span>-th matrix will be </li></ul><p class="math-container">\[\begin{bmatrix}\mu_i &amp; 0 \\ 0 &amp; \mu_{i+4mn} \end{bmatrix}\]</p><ul><li>If <code>type==3</code>, the <span>$i$</span>-th matrix will be </li></ul><p class="math-container">\[\begin{bmatrix}\mu_i &amp; \mu_{i+8mn} \\ \mu_{i+8mn} &amp; \mu_{i+4mn}\end{bmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/InvCore.jl#L189-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.mantle_viscosity" href="#AdFem.mantle_viscosity"><code>AdFem.mantle_viscosity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mantle_viscosity(u::Union{Array{Float64}, PyObject},
    T::Union{Array{Float64}, PyObject}, m::Int64, n::Int64, h::Float64;
    σ_yield::Union{Float64, PyObject} = 300e6, 
    ω::Union{Float64, PyObject}, 
    η_min::Union{Float64, PyObject} = 1e18, 
    η_max::Union{Float64, PyObject} = 1e23, 
    E::Union{Float64, PyObject} = 9.0, 
    C::Union{Float64, PyObject} = 1000., N::Union{Float64, PyObject} = 2.)</code></pre><p class="math-container">\[\eta = \eta_{\min} + \min\left( \frac{\sigma_{\text{yield}}}{2\sqrt{\epsilon_{II}}}, \omega\min(\eta_{\max}, \eta) \right)\]</p><p>with  </p><p class="math-container">\[\epsilon_{II} = \frac{1}{2} \epsilon(u)\qquad \eta = C e^{E(0.5-T)} (\epsilon_{II})^{(1-n)/2n}\]</p><p>Here <span>$\epsilon_{II}$</span> is the second invariant of the strain rate tensor, <span>$C &gt; 0$</span> is a viscosity pre-factor, <span>$E &gt; 0$</span> is the non-dimensional activation energy, <span>$n &gt; 0$</span> is the nonlinear exponent, <span>$η_\min$</span>, <span>$η_\max$</span> act as minimum and maximum bounds for the effective viscosity, and <span>$σ_{\text{yield}} &gt; 0$</span> is the yield stress. <span>$w\in (0, 1]$</span> is the weakening factor, which is used to incorporate phenomenological aspects that cannot be represented in a purely viscous flow model, such as processes which govern mega-thrust faults along the subduction interface, or partial melting near a mid-ocean ridge.</p><p>The viscosity of the mantle is governed by the high-temperature creep of silicates, for which laboratory experiments show that the creep strength is temperature-, pressure-, compositional- and stress-dependent. </p><p>The output is a length <span>$4mn$</span> vector. </p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>See <strong>Towards adjoint-based inversion of time-dependent mantle convection with nonlinear viscosity</strong> for details.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Constitutive.jl#L25-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.antiplane_viscosity" href="#AdFem.antiplane_viscosity"><code>AdFem.antiplane_viscosity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">antiplane_viscosity(ε::Union{PyObject, Array{Float64}}, σ::Union{PyObject, Array{Float64}}, 
μ::Union{PyObject, Float64}, η::Union{PyObject, Float64}, Δt::Float64)</code></pre><p>Calculates the stress at time <span>$t_{n+1}$</span> given the strain at <span>$t_{n+1}$</span> and stress at <span>$t_{n}$</span>. The governing equation is </p><p class="math-container">\[\dot\sigma + \frac{\mu}{\eta}\sigma = 2\mu \dot\epsilon\]</p><p>The discretization form is </p><p class="math-container">\[\sigma^{n+1} = \frac{1}{\frac{1}{\Delta t}+\frac{\mu}{\eta}}(2\mu\dot\epsilon^{n+1} + \frac{\sigma^n}{\Delta t})\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Constitutive.jl#L2-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.update_stress_viscosity" href="#AdFem.update_stress_viscosity"><code>AdFem.update_stress_viscosity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">update_stress_viscosity(ε2::Array{Float64,2}, ε1::Array{Float64,2}, σ1::Array{Float64,2}, 
invη::Array{Float64,1}, μ::Array{Float64,1}, λ::Array{Float64,1}, Δt::Float64)</code></pre><p>Updates the stress for the Maxwell model </p><p class="math-container">\[\begin{bmatrix} \dot\sigma_{xx}\ \dot\sigma_{yy}\ \dot\sigma_{xy} \end{bmatrix} + \frac{\mu}{\eta}\begin{bmatrix} 2/3 &amp; -1/3 &amp; 0 \ -1/3 &amp; 2/3 &amp; 0 \ 0 &amp; 0 &amp; 1 \end{bmatrix}\begin{bmatrix} \sigma_{xx}\ \sigma_{yy}\ \sigma_{xy}\end{bmatrix} = \begin{bmatrix} 2\mu + \lambda &amp; \lambda &amp; 0 \ \lambda &amp; 2\mu + \lambda &amp; 0 \ 0 &amp; 0 &amp; \mu \end{bmatrix}\begin{bmatrix} \dot\epsilon_{xx}\ \dot\epsilon_{yy}\ \dot\gamma_{xy} \end{bmatrix}\]</p><p>See <a href="https://kailaix.github.io/AdFem.jl/dev/viscoelasticity/#Numerical-Example">here</a> for details. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/InvCore.jl#L506-L515">source</a></section><section><div><pre><code class="nohighlight">update_stress_viscosity(ε2::Union{PyObject,Array{Float64,2}}, ε1::Union{PyObject,Array{Float64,2}}, σ1::Union{PyObject,Array{Float64,2}}, 
invη::Union{PyObject,Array{Float64,1}}, μ::Union{PyObject,Array{Float64,1}}, λ::Union{PyObject,Array{Float64,1}}, Δt::Union{PyObject,Float64})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/InvCore.jl#L527-L530">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.compute_pml_term" href="#AdFem.compute_pml_term"><code>AdFem.compute_pml_term</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_pml_term(u::Union{Array{Float64,1}, PyObject},βprime::Union{Array{Float64,1}, PyObject},
c::Union{Array{Float64,1}, PyObject},nv::Union{Array{Float64,2}, PyObject}, mmesh::Mesh)</code></pre><ul><li><code>u</code>: a vector of length <code>mmesh.ndof</code></li><li><code>βprime</code>: a vector of length <span>$n_{\text{gauss}}$</span></li><li><code>c</code>: a tensor of size <span>$n_{\text{gauss}}$</span></li><li><code>nv</code>: a matrix of size <span>$n_{\text{gauss}}\times 2$</span></li></ul><p>This function returns four outputs</p><p class="math-container">\[\begin{aligned}k_1&amp;=(c^2 n\partial_n u, n\partial_n\delta u)\\k_2&amp;=(\beta&#39;n\cdot(c^2 n\partial_n u), \delta u)\\ k_3&amp;=(c^2\nabla^\parallel u, n\partial_n \delta u) + (c^2 n\partial_ n u, \nabla^\parallel \delta u)\\ k_4&amp;= (c^2 \nabla^\parallel u, \nabla^\parallel \delta u)\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MUtils.jl#L313-L326">source</a></section><section><div><pre><code class="nohighlight">compute_pml_term(u::Union{Array{Float64,1}, PyObject},βprime::Union{Array{Float64,1}, PyObject},
λ::Union{Array{Float64,1}, PyObject},μ::Union{Array{Float64,1}, PyObject}, nv::Union{Array{Float64,2}, PyObject}, mmesh::Mesh)</code></pre><ul><li><code>u</code>: a vector of length <code>mmesh.ndof</code></li><li><code>βprime</code>: a vector of length <span>$n_{\text{gauss}}$</span></li><li><code>λ</code>, <code>μ</code>: Lam\&#39;e parameters</li><li><code>nv</code>: a matrix of size <span>$n_{\text{gauss}}\times 2$</span></li></ul><p>This is a 2D version of <a href="#AdFem.compute_pml_term"><code>compute_pml_term</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MUtils.jl#L338-L349">source</a></section><section><div><pre><code class="nohighlight">compute_pml_term(u::Union{Array{Float64,1}, PyObject},
    βprime::Union{Array{Float64,1}, PyObject},
    λ::Union{Array{Float64,1}, PyObject},μ::Union{Array{Float64,1}, PyObject}, 
    nv::Union{Array{Float64,2}, PyObject}, mmesh::Mesh3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM3/MUtils.jl#L91-L96">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>compute_absorbing_boundary_condition_matrix</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="AdFem.solve_slip_law" href="#AdFem.solve_slip_law"><code>AdFem.solve_slip_law</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">solve_slip_law(v, ψ, dc, v0, a, b, f0, Δt::Float64)</code></pre><p>Solves one step of the slip law equation </p><p class="math-container">\[\dot \psi = - \frac{|V|}{d_C}\left( a \sinh^{-1}\left( \frac{|V|}{2V_0}e^{\frac{\psi}{a}} \right) - f_0 + (b-a)*\log \frac{|V|}{V_0} \right)\]</p><p>We discretize the equation with a central difference scheme </p><p class="math-container">\[\frac{\psi^{n+1} - \psi^{n-1}}{2\Delta t} =  - \frac{|V|}{d_c}\left( a \sinh^{-1} \left( \frac{|V|}{2V_0} e^{\frac{\psi^{n+1} + \psi^{n-1}}{2a}{}} \right) - f_0 + (b-a) \log \frac{|V|}{V_0} \right)\]</p><ul><li><code>dc</code>, <code>v0</code>, <code>a</code>, <code>b</code>, and <code>f0</code> are scalars </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MUtils.jl#L361-L373">source</a></section><section><div><pre><code class="nohighlight">solve_slip_law( 
    A::Union{Array{Float64,1}, PyObject}, 
    B::Union{Array{Float64,1}, PyObject}, 
    C::Union{Array{Float64,1}, PyObject},
    X0::Union{Array{Float64,1}, PyObject})</code></pre><p>A helper function for <a href="#AdFem.solve_slip_law"><code>solve_slip_law</code></a> the nonlinear equation </p><p class="math-container">\[x - A\sinh^{-1}(Bx) - C = 0\]</p><p><code>A</code>, <code>B</code>, and <code>C</code> are vectors of the same length. <code>X0</code> is the initial guess. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MUtils.jl#L387-L399">source</a></section></article><h2 id="Mesh"><a class="docs-heading-anchor" href="#Mesh">Mesh</a><a id="Mesh-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="AdFem.get_edge_dof" href="#AdFem.get_edge_dof"><code>AdFem.get_edge_dof</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_edge_dof(edges::Array{Int64, 2}, mesh::Mesh)
get_edge_dof(edges::Array{Int64, 1}, mesh::Mesh)</code></pre><p>Returns the DOFs for <code>edges</code>, which is a <code>K × 2</code> array containing vertex indices.  The DOFs are not offset by <code>nnode</code>, i.e., the smallest edge DOF could be 1. </p><p>When the input is a length 2 vector, it returns a single index for the corresponding edge DOF. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MUtils.jl#L140-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.get_edge_normal" href="#AdFem.get_edge_normal"><code>AdFem.get_edge_normal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_edge_normal(edge::Array{Int64,1}, m::Int64, n::Int64, h::Float64)</code></pre><p>Returns the normal vector given edge <code>edge</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Utils.jl#L68-L72">source</a></section><section><div><pre><code class="nohighlight">get_edge_normal(mmesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MUtils.jl#L52-L54">source</a></section><section><div><pre><code class="nohighlight">get_edge_normal(bdedge::Array{Int64, 2}, mmesh::Mesh)</code></pre><p>Returns the outer normal for all edges in <code>bdedge</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MUtils.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.get_boundary_edge_orientation" href="#AdFem.get_boundary_edge_orientation"><code>AdFem.get_boundary_edge_orientation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_boundary_edge_orientation(bdedge::Array{Int64, 2}, mmesh::Mesh)</code></pre><p>Returns the orientation of the edges in <code>bdedge</code>. For example, if for a boundary element <code>[1,2,3]</code>, assume <code>[1,2]</code> is the boundary edge,  then </p><pre><code class="nohighlight">get_boundary_edge_orientation([1 2;2 1], mmesh) = [1.0;-1.0]</code></pre><p>The return values for non-boundary edges in <code>bdedge</code> is undefined. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MUtils.jl#L273-L284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.get_area" href="#AdFem.get_area"><code>AdFem.get_area</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_ngauss(mesh::Mesh)</code></pre><p>Return the areas of triangles as an array. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MFEM.jl#L211-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.get_ngauss" href="#AdFem.get_ngauss"><code>AdFem.get_ngauss</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_ngauss(mesh::Mesh)</code></pre><p>Return the total number of Gauss points. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MFEM.jl#L202-L206">source</a></section><section><div><pre><code class="nohighlight">get_ngauss(mesh::Mesh3)</code></pre><p>Return the total number of Gauss points. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM3/MFEM.jl#L240-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.bcnode" href="#AdFem.bcnode"><code>AdFem.bcnode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bcnode(desc::String, m::Int64, n::Int64, h::Float64)</code></pre><p>Returns the node indices for the description. Multiple descriptions can be concatented via <code>|</code></p><pre><code class="nohighlight">                upper
        |------------------|
left    |                  | right
        |                  |
        |__________________|

                lower</code></pre><p><strong>Example</strong></p><pre><code class="language-julia">bcnode(&quot;left|upper&quot;, m, n, h)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Utils.jl#L117-L136">source</a></section><section><div><pre><code class="nohighlight">bcnode(mesh::Mesh; by_dof::Bool = true)</code></pre><p>Returns all boundary node indices. </p><p>If <code>by_dof = true</code>, <code>bcnode</code> returns the global indices for boundary DOFs. </p><ul><li>For <code>P2</code> elements, the returned values are boundary node DOFs + boundary edge DOFs (offseted by <code>mesh.nnode</code>)</li><li>For <code>BDM1</code> elements, the returned values are boundary edge DOFs + boundary edge DOFs offseted by <code>mesh.nedge</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L429-L438">source</a></section><section><div><pre><code class="nohighlight">bcnode(f::Function, mesh::Mesh; by_dof::Bool = true)</code></pre><p>Returns the boundary node DOFs that satisfies <code>f(x,y) = true</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For BDM1 element and <code>by_dof = true</code>, because the degrees of freedoms are associated with edges, <code>f</code> has the signature</p><pre><code class="language-julia">f(x1::Float64, y1::Float64, x2::Float64, y2::Float64)::Bool</code></pre><p><code>bcnode</code> only returns DOFs on edges such that <code>f(x1, y1, x2, y2)=true</code>. </p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L452-L467">source</a></section><section><div><pre><code class="nohighlight">bcnode(mmesh::Mesh3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM3/MUtils.jl#L30-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.bcedge" href="#AdFem.bcedge"><code>AdFem.bcedge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bcedge(desc::String, m::Int64, n::Int64, h::Float64)</code></pre><p>Returns the edge indices for description. See <a href="#AdFem.bcnode"><code>bcnode</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Utils.jl#L96-L100">source</a></section><section><div><pre><code class="nohighlight">bcedge(mesh::Mesh)</code></pre><p>Returns all boundary edges as a set of integer pairs (edge vertices).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L380-L384">source</a></section><section><div><pre><code class="nohighlight">bcedge(f::Function, mesh::Mesh)</code></pre><p>Returns all edge indices that satisfies <code>f(x1, y1, x2, y2) = true</code> Here the edge endpoints are given by <span>$(x_1, y_1)$</span> and <span>$(x_2, y_2)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L408-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.interior_node" href="#AdFem.interior_node"><code>AdFem.interior_node</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">interior_node(desc::String, m::Int64, n::Int64, h::Float64)</code></pre><p>In contrast to <a href="#AdFem.bcnode"><code>bcnode</code></a>, <code>interior_node</code> returns the nodes that are not specified by <code>desc</code>, including those on the boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Utils.jl#L168-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.femidx" href="#AdFem.femidx"><code>AdFem.femidx</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">femidx(d::Int64, m::Int64)</code></pre><p>Returns the FEM index of the dof <code>d</code>. Basically, <code>femidx</code> is the inverse of </p><pre><code class="nohighlight">(i,j) → d = (j-1)*(m+1) + i</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Utils.jl#L6-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.fvmidx" href="#AdFem.fvmidx"><code>AdFem.fvmidx</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fvmidx(d::Int64, m::Int64)</code></pre><p>Returns the FVM index of the dof <code>d</code>. Basically, <code>femidx</code> is the inverse of </p><pre><code class="nohighlight">(i,j) → d = (j-1)*m + i</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Utils.jl#L22-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.subdomain" href="#AdFem.subdomain"><code>AdFem.subdomain</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">subdomain(f::Function, m::Int64, n::Int64, h::Float64)</code></pre><p>Returns the subdomain defined by <code>f(x, y)==true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Utils.jl#L289-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.gauss_nodes" href="#AdFem.gauss_nodes"><code>AdFem.gauss_nodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gauss_nodes(m::Int64, n::Int64, h::Float64)</code></pre><p>Returns the node matrix of Gauss points for all elements. The matrix has a size <span>$4mn\times 2$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Utils.jl#L200-L204">source</a></section><section><div><pre><code class="nohighlight">gauss_nodes(mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MFEM.jl#L223-L225">source</a></section><section><div><pre><code class="nohighlight">gauss_nodes(mesh::Mesh3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM3/MFEM.jl#L261-L263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.gauss_weights" href="#AdFem.gauss_weights"><code>AdFem.gauss_weights</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gauss_weights(mmesh::Mesh)</code></pre><p>Returns the weights for each Gauss points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MCore.jl#L765-L769">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.fem_nodes" href="#AdFem.fem_nodes"><code>AdFem.fem_nodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fem_nodes(m::Int64, n::Int64, h::Float64)</code></pre><p>Returns the FEM node matrix of size <span>$(m+1)(n+1)\times 2$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Utils.jl#L227-L231">source</a></section><section><div><pre><code class="nohighlight">fem_nodes(mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MFEM.jl#L234-L236">source</a></section><section><div><pre><code class="nohighlight">fem_nodes(mesh::Mesh3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM3/MFEM.jl#L273-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.fvm_nodes" href="#AdFem.fvm_nodes"><code>AdFem.fvm_nodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fvm_nodes(m::Int64, n::Int64, h::Float64)</code></pre><p>Returns the FVM node matrix of size <span>$(m+1)(n+1)\times 2$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Utils.jl#L247-L251">source</a></section><section><div><pre><code class="nohighlight">fvm_nodes(mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MFEM.jl#L241-L243">source</a></section><section><div><pre><code class="nohighlight">fvm_nodes(mesh::Mesh3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM3/MFEM.jl#L280-L282">source</a></section></article><h2 id="Physics-Constrained-Learning"><a class="docs-heading-anchor" href="#Physics-Constrained-Learning">Physics Constrained Learning</a><a id="Physics-Constrained-Learning-1"></a><a class="docs-heading-anchor-permalink" href="#Physics-Constrained-Learning" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="AdFem.pcl_impose_Dirichlet_boundary_conditions" href="#AdFem.pcl_impose_Dirichlet_boundary_conditions"><code>AdFem.pcl_impose_Dirichlet_boundary_conditions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pcl_impose_Dirichlet_boundary_conditions(indices::Array{Int64, 2}, bdnode::Array{Int64, 1}, outdof::Int64)</code></pre><p>Computes the Jacobian matrix for <a href="#AdFem.impose_Dirichlet_boundary_conditions"><code>impose_Dirichlet_boundary_conditions</code></a>. Assume that <code>impose_Dirichlet_boundary_conditions</code> transforms a sparse matrix <code>A</code> to <code>B</code>, and <code>v_A</code> and <code>v_B</code> are the nonzero entries, this function computes </p><p class="math-container">\[J_{ij} = \frac{\partial (v_B)_j}{\partial (v_A)_i}\]</p><ul><li><code>indices</code>: the <strong>1-based</strong> <span>$n_A\times 2$</span> index array for <code>A</code>;</li><li><code>bdnode</code>: boundary DOF (the same as inputs to <code>impose_Dirichlet_boundary_conditions</code>)</li><li><code>outdof</code>: the number of nonzero entries in <code>B</code>, i.e., length of <code>v_B</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/pcl.jl#L2-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.pcl_compute_fem_laplace_matrix1" href="#AdFem.pcl_compute_fem_laplace_matrix1"><code>AdFem.pcl_compute_fem_laplace_matrix1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pcl_compute_fem_laplace_matrix1(mmesh::Mesh)</code></pre><p>Computes the Jacobian matrix for <a href="#AdFem.pcl_compute_fem_laplace_matrix1"><code>pcl_compute_fem_laplace_matrix1</code></a>. Assume we contruct a sparse matrix via </p><pre><code class="language-julia">A = compute_fem_laplace_matrix1(κ, mmesh)
v = A.o.values </code></pre><p>Then the function returns </p><p class="math-container">\[J = \frac{\partial v_j}{\partial κ_i}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/pcl.jl#L23-L34">source</a></section></article><h2 id="Misc"><a class="docs-heading-anchor" href="#Misc">Misc</a><a id="Misc-1"></a><a class="docs-heading-anchor-permalink" href="#Misc" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="AdFem.trim_coupled" href="#AdFem.trim_coupled"><code>AdFem.trim_coupled</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">trim_coupled(pd::PoreData, Q::SparseMatrixCSC{Float64,Int64}, L::SparseMatrixCSC{Float64,Int64}, 
M::SparseMatrixCSC{Float64,Int64}, 
bd::Array{Int64}, Δt::Float64, m::Int64, n::Int64, h::Float64)</code></pre><p>Assembles matrices from mechanics and flow and assemble the coupled matrix </p><p class="math-container">\[\begin{bmatrix}
\hat M &amp; -\hat L^T\\
\hat L &amp; \hat Q
\end{bmatrix}\]</p><p><code>Q</code> is obtained from <a href="#AdFem.compute_fvm_tpfa_matrix"><code>compute_fvm_tpfa_matrix</code></a>, <code>M</code> is obtained from <a href="#AdFem.compute_fem_stiffness_matrix"><code>compute_fem_stiffness_matrix</code></a>, and <code>L</code> is obtained from <a href="#AdFem.compute_interaction_matrix"><code>compute_interaction_matrix</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L667-L682">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.coupled_impose_pressure" href="#AdFem.coupled_impose_pressure"><code>AdFem.coupled_impose_pressure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">coupled_impose_pressure(A::SparseMatrixCSC{Float64,Int64}, pnode::Array{Int64}, 
m::Int64, n::Int64, h::Float64)</code></pre><p>Returns a trimmed matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Core.jl#L701-L706">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.cholesky_factorize" href="#AdFem.cholesky_factorize"><code>AdFem.cholesky_factorize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cholesky_factorize(A::Union{Array{&lt;:Real,2}, PyObject})</code></pre><p>Returns the cholesky factor of <code>A</code>. See <a href="#AdFem.cholesky_outproduct"><code>cholesky_outproduct</code></a> for details. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Utils.jl#L320-L324">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.cholesky_outproduct" href="#AdFem.cholesky_outproduct"><code>AdFem.cholesky_outproduct</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cholesky_outproduct(L::Union{Array{&lt;:Real,2}, PyObject})</code></pre><p>Returns  <span>$A = LL&#39;$</span> where <code>L</code> (length=6) is a vectorized form of <span>$L$</span> <span>$L = \begin{matrix} l_1 &amp; 0 &amp; 0\\  l_4 &amp; l_2 &amp; 0 \\  l_5 &amp; l_6 &amp; l_3 \end{matrix}$</span> and <code>A</code> (length=9) is also a vectorized form of <span>$A$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Utils.jl#L300-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.fem_to_fvm" href="#AdFem.fem_to_fvm"><code>AdFem.fem_to_fvm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fem_to_fvm(u::Union{PyObject, Array{Float64}}, m::Int64, n::Int64, h::Float64)</code></pre><p>Interpolates the nodal values of <code>u</code> to cell values. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Utils.jl#L179-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.fem_to_gauss_points" href="#AdFem.fem_to_gauss_points"><code>AdFem.fem_to_gauss_points</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fem_to_gauss_points(u::PyOject, m::Int64, n::Int64, h::Float64)
fem_to_gauss_points(u::Array{Float64,1}, m::Int64, n::Int64, h::Float64)</code></pre><p>Given a vector of length <span>$(m+1)(n+1)$</span>, <code>u</code>, returns the function values at each Gauss point. </p><p>Returns a vector of length <span>$4mn$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/Utils.jl#L345-L352">source</a></section><section><div><pre><code class="nohighlight">fem_to_gauss_points(u::PyObject, mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MUtils.jl#L228-L230">source</a></section><section><div><pre><code class="nohighlight">fem_to_gauss_points(u::Array{Float64,1}, mesh::Mesh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MUtils.jl#L238-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdFem.dof_to_gauss_points" href="#AdFem.dof_to_gauss_points"><code>AdFem.dof_to_gauss_points</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dof_to_gauss_points(u::PyObject, mesh::Mesh)
dof_to_gauss_points(u::Array{Float64,1}, mesh::Mesh)</code></pre><p>Similar to <a href="#AdFem.fem_to_gauss_points"><code>fem_to_gauss_points</code></a>. The only difference is that the function uses all DOFs–-which means,  for quadratic elements, the nodal values on the edges are also used. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/AdFem.jl/blob/e90fc686f59d8adf8f89aad58594ba7311d777aa/src/MFEM/MUtils.jl#L249-L255">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../mfem3d/">« Working with 3D Domains</a><a class="docs-footer-nextpage" href="../docker_install_guide/">Install &amp; Reproduce AdFem With Docker Guide »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 19 June 2021 01:05">Saturday 19 June 2021</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
